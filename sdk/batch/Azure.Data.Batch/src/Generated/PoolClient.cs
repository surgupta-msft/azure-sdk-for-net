// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Data.Batch
{
    /// <summary> The Pool service client. </summary>
    public partial class PoolClient
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://batch.core.windows.net/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly string _batchUrl;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of PoolClient for mocking. </summary>
        protected PoolClient()
        {
        }

        /// <summary> Initializes a new instance of PoolClient. </summary>
        /// <param name="batchUrl"> The base URL for all Azure Batch service requests. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="batchUrl"/> or <paramref name="credential"/> is null. </exception>
        public PoolClient(string batchUrl, TokenCredential credential, BatchServiceClientOptions options = null)
        {
            Argument.AssertNotNull(batchUrl, nameof(batchUrl));
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new BatchServiceClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options);
            _tokenCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential, AuthorizationScopes) }, new ResponseClassifier());
            _batchUrl = batchUrl;
            _apiVersion = options.Version;
        }

        /// <summary> Statistics are aggregated across all Pools that have ever existed in the Account, from Account creation to the last update time of the statistics. The statistics may not be immediately available. The Batch service performs periodic roll-up of statistics. The typical delay is about 30 minutes. </summary>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   url: string,
        ///   startTime: string (ISO 8601 Format),
        ///   lastUpdateTime: string (ISO 8601 Format),
        ///   usageStats: {
        ///     startTime: string (ISO 8601 Format),
        ///     lastUpdateTime: string (ISO 8601 Format),
        ///     dedicatedCoreTime: UsageStatisticsDedicatedCoreTime
        ///   },
        ///   resourceStats: {
        ///     startTime: string (ISO 8601 Format),
        ///     lastUpdateTime: string (ISO 8601 Format),
        ///     avgCPUPercentage: number,
        ///     avgMemoryGiB: number,
        ///     peakMemoryGiB: number,
        ///     avgDiskGiB: number,
        ///     peakDiskGiB: number,
        ///     diskReadIOps: number,
        ///     diskWriteIOps: number,
        ///     diskReadGiB: number,
        ///     diskWriteGiB: number,
        ///     networkReadGiB: number,
        ///     networkWriteGiB: number
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetAllLifetimeStatisticsAsync(int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("PoolClient.GetAllLifetimeStatistics");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetAllLifetimeStatisticsRequest(timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Statistics are aggregated across all Pools that have ever existed in the Account, from Account creation to the last update time of the statistics. The statistics may not be immediately available. The Batch service performs periodic roll-up of statistics. The typical delay is about 30 minutes. </summary>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   url: string,
        ///   startTime: string (ISO 8601 Format),
        ///   lastUpdateTime: string (ISO 8601 Format),
        ///   usageStats: {
        ///     startTime: string (ISO 8601 Format),
        ///     lastUpdateTime: string (ISO 8601 Format),
        ///     dedicatedCoreTime: UsageStatisticsDedicatedCoreTime
        ///   },
        ///   resourceStats: {
        ///     startTime: string (ISO 8601 Format),
        ///     lastUpdateTime: string (ISO 8601 Format),
        ///     avgCPUPercentage: number,
        ///     avgMemoryGiB: number,
        ///     peakMemoryGiB: number,
        ///     avgDiskGiB: number,
        ///     peakDiskGiB: number,
        ///     diskReadIOps: number,
        ///     diskWriteIOps: number,
        ///     diskReadGiB: number,
        ///     diskWriteGiB: number,
        ///     networkReadGiB: number,
        ///     networkWriteGiB: number
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetAllLifetimeStatistics(int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("PoolClient.GetAllLifetimeStatistics");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetAllLifetimeStatisticsRequest(timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> When naming Pools, avoid including sensitive information such as user names or secret project names. This information may appear in telemetry logs accessible to Microsoft Support engineers. </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   id: string (required),
        ///   displayName: string,
        ///   vmSize: string (required),
        ///   cloudServiceConfiguration: {
        ///     osFamily: string (required),
        ///     osVersion: string
        ///   },
        ///   virtualMachineConfiguration: {
        ///     imageReference: {
        ///       publisher: string,
        ///       offer: string,
        ///       sku: string,
        ///       version: string,
        ///       virtualMachineImageId: string,
        ///       exactVersion: string
        ///     } (required),
        ///     nodeAgentSKUId: string (required),
        ///     windowsConfiguration: {
        ///       enableAutomaticUpdates: boolean
        ///     },
        ///     dataDisks: [
        ///       {
        ///         lun: number (required),
        ///         caching: CachingType,
        ///         diskSizeGB: number (required),
        ///         storageAccountType: StorageAccountType
        ///       }
        ///     ],
        ///     licenseType: string,
        ///     containerConfiguration: {
        ///       type: ContainerType (required),
        ///       containerImageNames: [string],
        ///       containerRegistries: [
        ///         {
        ///           username: string,
        ///           password: string,
        ///           registryServer: string,
        ///           identityReference: {
        ///             resourceId: string
        ///           }
        ///         }
        ///       ]
        ///     },
        ///     diskEncryptionConfiguration: {
        ///       targets: [DiskEncryptionTarget]
        ///     },
        ///     nodePlacementConfiguration: {
        ///       policy: NodePlacementPolicyType
        ///     },
        ///     extensions: [
        ///       {
        ///         name: string (required),
        ///         publisher: string (required),
        ///         type: string (required),
        ///         typeHandlerVersion: string,
        ///         autoUpgradeMinorVersion: boolean,
        ///         settings: AnyObject,
        ///         protectedSettings: AnyObject,
        ///         provisionAfterExtensions: [string]
        ///       }
        ///     ],
        ///     osDisk: {
        ///       ephemeralOSDiskSettings: {
        ///         placement: DiffDiskPlacement
        ///       }
        ///     }
        ///   },
        ///   resizeTimeout: PoolAddParameterResizeTimeout,
        ///   targetDedicatedNodes: number,
        ///   targetLowPriorityNodes: number,
        ///   enableAutoScale: boolean,
        ///   autoScaleFormula: string,
        ///   autoScaleEvaluationInterval: PoolAddParameterAutoScaleEvaluationInterval,
        ///   enableInterNodeCommunication: boolean,
        ///   networkConfiguration: {
        ///     subnetId: string,
        ///     dynamicVNetAssignmentScope: DynamicVNetAssignmentScope,
        ///     endpointConfiguration: {
        ///       inboundNATPools: [
        ///         {
        ///           name: string (required),
        ///           protocol: InboundEndpointProtocol (required),
        ///           backendPort: number (required),
        ///           frontendPortRangeStart: number (required),
        ///           frontendPortRangeEnd: number (required),
        ///           networkSecurityGroupRules: [
        ///             {
        ///               priority: number (required),
        ///               access: NetworkSecurityGroupRuleAccess (required),
        ///               sourceAddressPrefix: string (required),
        ///               sourcePortRanges: [string]
        ///             }
        ///           ]
        ///         }
        ///       ] (required)
        ///     },
        ///     publicIPAddressConfiguration: {
        ///       provision: IPAddressProvisioningType,
        ///       ipAddressIds: [string]
        ///     }
        ///   },
        ///   startTask: {
        ///     commandLine: string (required),
        ///     containerSettings: {
        ///       containerRunOptions: string,
        ///       imageName: string (required),
        ///       registry: ContainerRegistry,
        ///       workingDirectory: ContainerWorkingDirectory
        ///     },
        ///     resourceFiles: [
        ///       {
        ///         autoStorageContainerName: string,
        ///         storageContainerUrl: string,
        ///         httpUrl: string,
        ///         blobPrefix: string,
        ///         filePath: string,
        ///         fileMode: string,
        ///         identityReference: ComputeNodeIdentityReference
        ///       }
        ///     ],
        ///     environmentSettings: [
        ///       {
        ///         name: string (required),
        ///         value: string
        ///       }
        ///     ],
        ///     userIdentity: {
        ///       username: string,
        ///       autoUser: {
        ///         scope: AutoUserScope,
        ///         elevationLevel: ElevationLevel
        ///       }
        ///     },
        ///     maxTaskRetryCount: number,
        ///     waitForSuccess: boolean
        ///   },
        ///   certificateReferences: [
        ///     {
        ///       thumbprint: string (required),
        ///       thumbprintAlgorithm: string (required),
        ///       storeLocation: CertificateStoreLocation,
        ///       storeName: string,
        ///       visibility: [CertificateVisibility]
        ///     }
        ///   ],
        ///   applicationPackageReferences: [
        ///     {
        ///       applicationId: string (required),
        ///       version: string
        ///     }
        ///   ],
        ///   applicationLicenses: [string],
        ///   taskSlotsPerNode: number,
        ///   taskSchedulingPolicy: {
        ///     nodeFillType: ComputeNodeFillType (required)
        ///   },
        ///   userAccounts: [
        ///     {
        ///       name: string (required),
        ///       password: string (required),
        ///       elevationLevel: ElevationLevel,
        ///       linuxUserConfiguration: {
        ///         uid: number,
        ///         gid: number,
        ///         sshPrivateKey: string
        ///       },
        ///       windowsUserConfiguration: {
        ///         loginMode: LoginMode
        ///       }
        ///     }
        ///   ],
        ///   metadata: [
        ///     {
        ///       name: string (required),
        ///       value: string (required)
        ///     }
        ///   ],
        ///   mountConfiguration: [
        ///     {
        ///       azureBlobFileSystemConfiguration: {
        ///         accountName: string (required),
        ///         containerName: string (required),
        ///         accountKey: string,
        ///         sasKey: string,
        ///         blobfuseOptions: string,
        ///         relativeMountPath: string (required),
        ///         identityReference: ComputeNodeIdentityReference
        ///       },
        ///       nfsMountConfiguration: {
        ///         source: string (required),
        ///         relativeMountPath: string (required),
        ///         mountOptions: string
        ///       },
        ///       cifsMountConfiguration: {
        ///         username: string (required),
        ///         source: string (required),
        ///         relativeMountPath: string (required),
        ///         mountOptions: string,
        ///         password: string (required)
        ///       },
        ///       azureFileShareConfiguration: {
        ///         accountName: string (required),
        ///         azureFileUrl: string (required),
        ///         accountKey: string (required),
        ///         relativeMountPath: string (required),
        ///         mountOptions: string
        ///       }
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> AddAsync(RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.Add");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddRequest(content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> When naming Pools, avoid including sensitive information such as user names or secret project names. This information may appear in telemetry logs accessible to Microsoft Support engineers. </summary>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   id: string (required),
        ///   displayName: string,
        ///   vmSize: string (required),
        ///   cloudServiceConfiguration: {
        ///     osFamily: string (required),
        ///     osVersion: string
        ///   },
        ///   virtualMachineConfiguration: {
        ///     imageReference: {
        ///       publisher: string,
        ///       offer: string,
        ///       sku: string,
        ///       version: string,
        ///       virtualMachineImageId: string,
        ///       exactVersion: string
        ///     } (required),
        ///     nodeAgentSKUId: string (required),
        ///     windowsConfiguration: {
        ///       enableAutomaticUpdates: boolean
        ///     },
        ///     dataDisks: [
        ///       {
        ///         lun: number (required),
        ///         caching: CachingType,
        ///         diskSizeGB: number (required),
        ///         storageAccountType: StorageAccountType
        ///       }
        ///     ],
        ///     licenseType: string,
        ///     containerConfiguration: {
        ///       type: ContainerType (required),
        ///       containerImageNames: [string],
        ///       containerRegistries: [
        ///         {
        ///           username: string,
        ///           password: string,
        ///           registryServer: string,
        ///           identityReference: {
        ///             resourceId: string
        ///           }
        ///         }
        ///       ]
        ///     },
        ///     diskEncryptionConfiguration: {
        ///       targets: [DiskEncryptionTarget]
        ///     },
        ///     nodePlacementConfiguration: {
        ///       policy: NodePlacementPolicyType
        ///     },
        ///     extensions: [
        ///       {
        ///         name: string (required),
        ///         publisher: string (required),
        ///         type: string (required),
        ///         typeHandlerVersion: string,
        ///         autoUpgradeMinorVersion: boolean,
        ///         settings: AnyObject,
        ///         protectedSettings: AnyObject,
        ///         provisionAfterExtensions: [string]
        ///       }
        ///     ],
        ///     osDisk: {
        ///       ephemeralOSDiskSettings: {
        ///         placement: DiffDiskPlacement
        ///       }
        ///     }
        ///   },
        ///   resizeTimeout: PoolAddParameterResizeTimeout,
        ///   targetDedicatedNodes: number,
        ///   targetLowPriorityNodes: number,
        ///   enableAutoScale: boolean,
        ///   autoScaleFormula: string,
        ///   autoScaleEvaluationInterval: PoolAddParameterAutoScaleEvaluationInterval,
        ///   enableInterNodeCommunication: boolean,
        ///   networkConfiguration: {
        ///     subnetId: string,
        ///     dynamicVNetAssignmentScope: DynamicVNetAssignmentScope,
        ///     endpointConfiguration: {
        ///       inboundNATPools: [
        ///         {
        ///           name: string (required),
        ///           protocol: InboundEndpointProtocol (required),
        ///           backendPort: number (required),
        ///           frontendPortRangeStart: number (required),
        ///           frontendPortRangeEnd: number (required),
        ///           networkSecurityGroupRules: [
        ///             {
        ///               priority: number (required),
        ///               access: NetworkSecurityGroupRuleAccess (required),
        ///               sourceAddressPrefix: string (required),
        ///               sourcePortRanges: [string]
        ///             }
        ///           ]
        ///         }
        ///       ] (required)
        ///     },
        ///     publicIPAddressConfiguration: {
        ///       provision: IPAddressProvisioningType,
        ///       ipAddressIds: [string]
        ///     }
        ///   },
        ///   startTask: {
        ///     commandLine: string (required),
        ///     containerSettings: {
        ///       containerRunOptions: string,
        ///       imageName: string (required),
        ///       registry: ContainerRegistry,
        ///       workingDirectory: ContainerWorkingDirectory
        ///     },
        ///     resourceFiles: [
        ///       {
        ///         autoStorageContainerName: string,
        ///         storageContainerUrl: string,
        ///         httpUrl: string,
        ///         blobPrefix: string,
        ///         filePath: string,
        ///         fileMode: string,
        ///         identityReference: ComputeNodeIdentityReference
        ///       }
        ///     ],
        ///     environmentSettings: [
        ///       {
        ///         name: string (required),
        ///         value: string
        ///       }
        ///     ],
        ///     userIdentity: {
        ///       username: string,
        ///       autoUser: {
        ///         scope: AutoUserScope,
        ///         elevationLevel: ElevationLevel
        ///       }
        ///     },
        ///     maxTaskRetryCount: number,
        ///     waitForSuccess: boolean
        ///   },
        ///   certificateReferences: [
        ///     {
        ///       thumbprint: string (required),
        ///       thumbprintAlgorithm: string (required),
        ///       storeLocation: CertificateStoreLocation,
        ///       storeName: string,
        ///       visibility: [CertificateVisibility]
        ///     }
        ///   ],
        ///   applicationPackageReferences: [
        ///     {
        ///       applicationId: string (required),
        ///       version: string
        ///     }
        ///   ],
        ///   applicationLicenses: [string],
        ///   taskSlotsPerNode: number,
        ///   taskSchedulingPolicy: {
        ///     nodeFillType: ComputeNodeFillType (required)
        ///   },
        ///   userAccounts: [
        ///     {
        ///       name: string (required),
        ///       password: string (required),
        ///       elevationLevel: ElevationLevel,
        ///       linuxUserConfiguration: {
        ///         uid: number,
        ///         gid: number,
        ///         sshPrivateKey: string
        ///       },
        ///       windowsUserConfiguration: {
        ///         loginMode: LoginMode
        ///       }
        ///     }
        ///   ],
        ///   metadata: [
        ///     {
        ///       name: string (required),
        ///       value: string (required)
        ///     }
        ///   ],
        ///   mountConfiguration: [
        ///     {
        ///       azureBlobFileSystemConfiguration: {
        ///         accountName: string (required),
        ///         containerName: string (required),
        ///         accountKey: string,
        ///         sasKey: string,
        ///         blobfuseOptions: string,
        ///         relativeMountPath: string (required),
        ///         identityReference: ComputeNodeIdentityReference
        ///       },
        ///       nfsMountConfiguration: {
        ///         source: string (required),
        ///         relativeMountPath: string (required),
        ///         mountOptions: string
        ///       },
        ///       cifsMountConfiguration: {
        ///         username: string (required),
        ///         source: string (required),
        ///         relativeMountPath: string (required),
        ///         mountOptions: string,
        ///         password: string (required)
        ///       },
        ///       azureFileShareConfiguration: {
        ///         accountName: string (required),
        ///         azureFileUrl: string (required),
        ///         accountKey: string (required),
        ///         relativeMountPath: string (required),
        ///         mountOptions: string
        ///       }
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response Add(RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.Add");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddRequest(content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> When you request that a Pool be deleted, the following actions occur: the Pool state is set to deleting; any ongoing resize operation on the Pool are stopped; the Batch service starts resizing the Pool to zero Compute Nodes; any Tasks running on existing Compute Nodes are terminated and requeued (as if a resize Pool operation had been requested with the default requeue option); finally, the Pool is removed from the system. Because running Tasks are requeued, the user can rerun these Tasks by updating their Job to target a different Pool. The Tasks can then run on the new Pool. If you want to override the requeue behavior, then you should call resize Pool explicitly to shrink the Pool to zero size before deleting the Pool. If you call an Update, Patch or Delete API on a Pool in the deleting state, it will fail with HTTP status code 409 with error code PoolBeingDeleted. </summary>
        /// <param name="poolId"> The ID of the Pool to delete. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> DeleteAsync(string poolId, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.Delete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteRequest(poolId, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> When you request that a Pool be deleted, the following actions occur: the Pool state is set to deleting; any ongoing resize operation on the Pool are stopped; the Batch service starts resizing the Pool to zero Compute Nodes; any Tasks running on existing Compute Nodes are terminated and requeued (as if a resize Pool operation had been requested with the default requeue option); finally, the Pool is removed from the system. Because running Tasks are requeued, the user can rerun these Tasks by updating their Job to target a different Pool. The Tasks can then run on the new Pool. If you want to override the requeue behavior, then you should call resize Pool explicitly to shrink the Pool to zero size before deleting the Pool. If you call an Update, Patch or Delete API on a Pool in the deleting state, it will fail with HTTP status code 409 with error code PoolBeingDeleted. </summary>
        /// <param name="poolId"> The ID of the Pool to delete. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response Delete(string poolId, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.Delete");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteRequest(poolId, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets basic properties of a Pool. </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> ExistsAsync(string poolId, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.Exists");
            scope.Start();
            try
            {
                using HttpMessage message = CreateExistsRequest(poolId, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets basic properties of a Pool. </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response Exists(string poolId, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.Exists");
            scope.Start();
            try
            {
                using HttpMessage message = CreateExistsRequest(poolId, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets information about the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   id: string,
        ///   displayName: string,
        ///   url: string,
        ///   eTag: string,
        ///   lastModified: string (ISO 8601 Format),
        ///   creationTime: string (ISO 8601 Format),
        ///   state: PoolState,
        ///   stateTransitionTime: string (ISO 8601 Format),
        ///   allocationState: AllocationState,
        ///   allocationStateTransitionTime: string (ISO 8601 Format),
        ///   vmSize: string,
        ///   cloudServiceConfiguration: {
        ///     osFamily: string,
        ///     osVersion: string
        ///   },
        ///   virtualMachineConfiguration: {
        ///     imageReference: {
        ///       publisher: string,
        ///       offer: string,
        ///       sku: string,
        ///       version: string,
        ///       virtualMachineImageId: string,
        ///       exactVersion: string
        ///     },
        ///     nodeAgentSKUId: string,
        ///     windowsConfiguration: {
        ///       enableAutomaticUpdates: boolean
        ///     },
        ///     dataDisks: [
        ///       {
        ///         lun: number,
        ///         caching: CachingType,
        ///         diskSizeGB: number,
        ///         storageAccountType: StorageAccountType
        ///       }
        ///     ],
        ///     licenseType: string,
        ///     containerConfiguration: {
        ///       type: ContainerType,
        ///       containerImageNames: [string],
        ///       containerRegistries: [
        ///         {
        ///           username: string,
        ///           password: string,
        ///           registryServer: string,
        ///           identityReference: {
        ///             resourceId: string
        ///           }
        ///         }
        ///       ]
        ///     },
        ///     diskEncryptionConfiguration: {
        ///       targets: [DiskEncryptionTarget]
        ///     },
        ///     nodePlacementConfiguration: {
        ///       policy: NodePlacementPolicyType
        ///     },
        ///     extensions: [
        ///       {
        ///         name: string,
        ///         publisher: string,
        ///         type: string,
        ///         typeHandlerVersion: string,
        ///         autoUpgradeMinorVersion: boolean,
        ///         settings: AnyObject,
        ///         protectedSettings: AnyObject,
        ///         provisionAfterExtensions: [string]
        ///       }
        ///     ],
        ///     osDisk: {
        ///       ephemeralOSDiskSettings: {
        ///         placement: DiffDiskPlacement
        ///       }
        ///     }
        ///   },
        ///   resizeTimeout: CloudPoolResizeTimeout,
        ///   resizeErrors: [
        ///     {
        ///       code: string,
        ///       message: string,
        ///       values: [
        ///         {
        ///           name: string,
        ///           value: string
        ///         }
        ///       ]
        ///     }
        ///   ],
        ///   currentDedicatedNodes: number,
        ///   currentLowPriorityNodes: number,
        ///   targetDedicatedNodes: number,
        ///   targetLowPriorityNodes: number,
        ///   enableAutoScale: boolean,
        ///   autoScaleFormula: string,
        ///   autoScaleEvaluationInterval: CloudPoolAutoScaleEvaluationInterval,
        ///   autoScaleRun: {
        ///     timestamp: string (ISO 8601 Format),
        ///     results: string,
        ///     error: {
        ///       code: string,
        ///       message: string,
        ///       values: [NameValuePair]
        ///     }
        ///   },
        ///   enableInterNodeCommunication: boolean,
        ///   networkConfiguration: {
        ///     subnetId: string,
        ///     dynamicVNetAssignmentScope: DynamicVNetAssignmentScope,
        ///     endpointConfiguration: {
        ///       inboundNATPools: [
        ///         {
        ///           name: string,
        ///           protocol: InboundEndpointProtocol,
        ///           backendPort: number,
        ///           frontendPortRangeStart: number,
        ///           frontendPortRangeEnd: number,
        ///           networkSecurityGroupRules: [
        ///             {
        ///               priority: number,
        ///               access: NetworkSecurityGroupRuleAccess,
        ///               sourceAddressPrefix: string,
        ///               sourcePortRanges: [string]
        ///             }
        ///           ]
        ///         }
        ///       ]
        ///     },
        ///     publicIPAddressConfiguration: {
        ///       provision: IPAddressProvisioningType,
        ///       ipAddressIds: [string]
        ///     }
        ///   },
        ///   startTask: {
        ///     commandLine: string,
        ///     containerSettings: {
        ///       containerRunOptions: string,
        ///       imageName: string,
        ///       registry: ContainerRegistry,
        ///       workingDirectory: ContainerWorkingDirectory
        ///     },
        ///     resourceFiles: [
        ///       {
        ///         autoStorageContainerName: string,
        ///         storageContainerUrl: string,
        ///         httpUrl: string,
        ///         blobPrefix: string,
        ///         filePath: string,
        ///         fileMode: string,
        ///         identityReference: ComputeNodeIdentityReference
        ///       }
        ///     ],
        ///     environmentSettings: [
        ///       {
        ///         name: string,
        ///         value: string
        ///       }
        ///     ],
        ///     userIdentity: {
        ///       username: string,
        ///       autoUser: {
        ///         scope: AutoUserScope,
        ///         elevationLevel: ElevationLevel
        ///       }
        ///     },
        ///     maxTaskRetryCount: number,
        ///     waitForSuccess: boolean
        ///   },
        ///   certificateReferences: [
        ///     {
        ///       thumbprint: string,
        ///       thumbprintAlgorithm: string,
        ///       storeLocation: CertificateStoreLocation,
        ///       storeName: string,
        ///       visibility: [CertificateVisibility]
        ///     }
        ///   ],
        ///   applicationPackageReferences: [
        ///     {
        ///       applicationId: string,
        ///       version: string
        ///     }
        ///   ],
        ///   applicationLicenses: [string],
        ///   taskSlotsPerNode: number,
        ///   taskSchedulingPolicy: {
        ///     nodeFillType: ComputeNodeFillType
        ///   },
        ///   userAccounts: [
        ///     {
        ///       name: string,
        ///       password: string,
        ///       elevationLevel: ElevationLevel,
        ///       linuxUserConfiguration: {
        ///         uid: number,
        ///         gid: number,
        ///         sshPrivateKey: string
        ///       },
        ///       windowsUserConfiguration: {
        ///         loginMode: LoginMode
        ///       }
        ///     }
        ///   ],
        ///   metadata: [
        ///     {
        ///       name: string,
        ///       value: string
        ///     }
        ///   ],
        ///   stats: {
        ///     url: string,
        ///     startTime: string (ISO 8601 Format),
        ///     lastUpdateTime: string (ISO 8601 Format),
        ///     usageStats: {
        ///       startTime: string (ISO 8601 Format),
        ///       lastUpdateTime: string (ISO 8601 Format),
        ///       dedicatedCoreTime: UsageStatisticsDedicatedCoreTime
        ///     },
        ///     resourceStats: {
        ///       startTime: string (ISO 8601 Format),
        ///       lastUpdateTime: string (ISO 8601 Format),
        ///       avgCPUPercentage: number,
        ///       avgMemoryGiB: number,
        ///       peakMemoryGiB: number,
        ///       avgDiskGiB: number,
        ///       peakDiskGiB: number,
        ///       diskReadIOps: number,
        ///       diskWriteIOps: number,
        ///       diskReadGiB: number,
        ///       diskWriteGiB: number,
        ///       networkReadGiB: number,
        ///       networkWriteGiB: number
        ///     }
        ///   },
        ///   mountConfiguration: [
        ///     {
        ///       azureBlobFileSystemConfiguration: {
        ///         accountName: string,
        ///         containerName: string,
        ///         accountKey: string,
        ///         sasKey: string,
        ///         blobfuseOptions: string,
        ///         relativeMountPath: string,
        ///         identityReference: ComputeNodeIdentityReference
        ///       },
        ///       nfsMountConfiguration: {
        ///         source: string,
        ///         relativeMountPath: string,
        ///         mountOptions: string
        ///       },
        ///       cifsMountConfiguration: {
        ///         username: string,
        ///         source: string,
        ///         relativeMountPath: string,
        ///         mountOptions: string,
        ///         password: string
        ///       },
        ///       azureFileShareConfiguration: {
        ///         accountName: string,
        ///         azureFileUrl: string,
        ///         accountKey: string,
        ///         relativeMountPath: string,
        ///         mountOptions: string
        ///       }
        ///     }
        ///   ],
        ///   identity: {
        ///     type: PoolIdentityType,
        ///     userAssignedIdentities: [
        ///       {
        ///         resourceId: string,
        ///         clientId: string,
        ///         principalId: string
        ///       }
        ///     ]
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetPoolAsync(string poolId, string select = null, string expand = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.GetPool");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPoolRequest(poolId, select, expand, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets information about the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool to get. </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   id: string,
        ///   displayName: string,
        ///   url: string,
        ///   eTag: string,
        ///   lastModified: string (ISO 8601 Format),
        ///   creationTime: string (ISO 8601 Format),
        ///   state: PoolState,
        ///   stateTransitionTime: string (ISO 8601 Format),
        ///   allocationState: AllocationState,
        ///   allocationStateTransitionTime: string (ISO 8601 Format),
        ///   vmSize: string,
        ///   cloudServiceConfiguration: {
        ///     osFamily: string,
        ///     osVersion: string
        ///   },
        ///   virtualMachineConfiguration: {
        ///     imageReference: {
        ///       publisher: string,
        ///       offer: string,
        ///       sku: string,
        ///       version: string,
        ///       virtualMachineImageId: string,
        ///       exactVersion: string
        ///     },
        ///     nodeAgentSKUId: string,
        ///     windowsConfiguration: {
        ///       enableAutomaticUpdates: boolean
        ///     },
        ///     dataDisks: [
        ///       {
        ///         lun: number,
        ///         caching: CachingType,
        ///         diskSizeGB: number,
        ///         storageAccountType: StorageAccountType
        ///       }
        ///     ],
        ///     licenseType: string,
        ///     containerConfiguration: {
        ///       type: ContainerType,
        ///       containerImageNames: [string],
        ///       containerRegistries: [
        ///         {
        ///           username: string,
        ///           password: string,
        ///           registryServer: string,
        ///           identityReference: {
        ///             resourceId: string
        ///           }
        ///         }
        ///       ]
        ///     },
        ///     diskEncryptionConfiguration: {
        ///       targets: [DiskEncryptionTarget]
        ///     },
        ///     nodePlacementConfiguration: {
        ///       policy: NodePlacementPolicyType
        ///     },
        ///     extensions: [
        ///       {
        ///         name: string,
        ///         publisher: string,
        ///         type: string,
        ///         typeHandlerVersion: string,
        ///         autoUpgradeMinorVersion: boolean,
        ///         settings: AnyObject,
        ///         protectedSettings: AnyObject,
        ///         provisionAfterExtensions: [string]
        ///       }
        ///     ],
        ///     osDisk: {
        ///       ephemeralOSDiskSettings: {
        ///         placement: DiffDiskPlacement
        ///       }
        ///     }
        ///   },
        ///   resizeTimeout: CloudPoolResizeTimeout,
        ///   resizeErrors: [
        ///     {
        ///       code: string,
        ///       message: string,
        ///       values: [
        ///         {
        ///           name: string,
        ///           value: string
        ///         }
        ///       ]
        ///     }
        ///   ],
        ///   currentDedicatedNodes: number,
        ///   currentLowPriorityNodes: number,
        ///   targetDedicatedNodes: number,
        ///   targetLowPriorityNodes: number,
        ///   enableAutoScale: boolean,
        ///   autoScaleFormula: string,
        ///   autoScaleEvaluationInterval: CloudPoolAutoScaleEvaluationInterval,
        ///   autoScaleRun: {
        ///     timestamp: string (ISO 8601 Format),
        ///     results: string,
        ///     error: {
        ///       code: string,
        ///       message: string,
        ///       values: [NameValuePair]
        ///     }
        ///   },
        ///   enableInterNodeCommunication: boolean,
        ///   networkConfiguration: {
        ///     subnetId: string,
        ///     dynamicVNetAssignmentScope: DynamicVNetAssignmentScope,
        ///     endpointConfiguration: {
        ///       inboundNATPools: [
        ///         {
        ///           name: string,
        ///           protocol: InboundEndpointProtocol,
        ///           backendPort: number,
        ///           frontendPortRangeStart: number,
        ///           frontendPortRangeEnd: number,
        ///           networkSecurityGroupRules: [
        ///             {
        ///               priority: number,
        ///               access: NetworkSecurityGroupRuleAccess,
        ///               sourceAddressPrefix: string,
        ///               sourcePortRanges: [string]
        ///             }
        ///           ]
        ///         }
        ///       ]
        ///     },
        ///     publicIPAddressConfiguration: {
        ///       provision: IPAddressProvisioningType,
        ///       ipAddressIds: [string]
        ///     }
        ///   },
        ///   startTask: {
        ///     commandLine: string,
        ///     containerSettings: {
        ///       containerRunOptions: string,
        ///       imageName: string,
        ///       registry: ContainerRegistry,
        ///       workingDirectory: ContainerWorkingDirectory
        ///     },
        ///     resourceFiles: [
        ///       {
        ///         autoStorageContainerName: string,
        ///         storageContainerUrl: string,
        ///         httpUrl: string,
        ///         blobPrefix: string,
        ///         filePath: string,
        ///         fileMode: string,
        ///         identityReference: ComputeNodeIdentityReference
        ///       }
        ///     ],
        ///     environmentSettings: [
        ///       {
        ///         name: string,
        ///         value: string
        ///       }
        ///     ],
        ///     userIdentity: {
        ///       username: string,
        ///       autoUser: {
        ///         scope: AutoUserScope,
        ///         elevationLevel: ElevationLevel
        ///       }
        ///     },
        ///     maxTaskRetryCount: number,
        ///     waitForSuccess: boolean
        ///   },
        ///   certificateReferences: [
        ///     {
        ///       thumbprint: string,
        ///       thumbprintAlgorithm: string,
        ///       storeLocation: CertificateStoreLocation,
        ///       storeName: string,
        ///       visibility: [CertificateVisibility]
        ///     }
        ///   ],
        ///   applicationPackageReferences: [
        ///     {
        ///       applicationId: string,
        ///       version: string
        ///     }
        ///   ],
        ///   applicationLicenses: [string],
        ///   taskSlotsPerNode: number,
        ///   taskSchedulingPolicy: {
        ///     nodeFillType: ComputeNodeFillType
        ///   },
        ///   userAccounts: [
        ///     {
        ///       name: string,
        ///       password: string,
        ///       elevationLevel: ElevationLevel,
        ///       linuxUserConfiguration: {
        ///         uid: number,
        ///         gid: number,
        ///         sshPrivateKey: string
        ///       },
        ///       windowsUserConfiguration: {
        ///         loginMode: LoginMode
        ///       }
        ///     }
        ///   ],
        ///   metadata: [
        ///     {
        ///       name: string,
        ///       value: string
        ///     }
        ///   ],
        ///   stats: {
        ///     url: string,
        ///     startTime: string (ISO 8601 Format),
        ///     lastUpdateTime: string (ISO 8601 Format),
        ///     usageStats: {
        ///       startTime: string (ISO 8601 Format),
        ///       lastUpdateTime: string (ISO 8601 Format),
        ///       dedicatedCoreTime: UsageStatisticsDedicatedCoreTime
        ///     },
        ///     resourceStats: {
        ///       startTime: string (ISO 8601 Format),
        ///       lastUpdateTime: string (ISO 8601 Format),
        ///       avgCPUPercentage: number,
        ///       avgMemoryGiB: number,
        ///       peakMemoryGiB: number,
        ///       avgDiskGiB: number,
        ///       peakDiskGiB: number,
        ///       diskReadIOps: number,
        ///       diskWriteIOps: number,
        ///       diskReadGiB: number,
        ///       diskWriteGiB: number,
        ///       networkReadGiB: number,
        ///       networkWriteGiB: number
        ///     }
        ///   },
        ///   mountConfiguration: [
        ///     {
        ///       azureBlobFileSystemConfiguration: {
        ///         accountName: string,
        ///         containerName: string,
        ///         accountKey: string,
        ///         sasKey: string,
        ///         blobfuseOptions: string,
        ///         relativeMountPath: string,
        ///         identityReference: ComputeNodeIdentityReference
        ///       },
        ///       nfsMountConfiguration: {
        ///         source: string,
        ///         relativeMountPath: string,
        ///         mountOptions: string
        ///       },
        ///       cifsMountConfiguration: {
        ///         username: string,
        ///         source: string,
        ///         relativeMountPath: string,
        ///         mountOptions: string,
        ///         password: string
        ///       },
        ///       azureFileShareConfiguration: {
        ///         accountName: string,
        ///         azureFileUrl: string,
        ///         accountKey: string,
        ///         relativeMountPath: string,
        ///         mountOptions: string
        ///       }
        ///     }
        ///   ],
        ///   identity: {
        ///     type: PoolIdentityType,
        ///     userAssignedIdentities: [
        ///       {
        ///         resourceId: string,
        ///         clientId: string,
        ///         principalId: string
        ///       }
        ///     ]
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetPool(string poolId, string select = null, string expand = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.GetPool");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetPoolRequest(poolId, select, expand, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This only replaces the Pool properties specified in the request. For example, if the Pool has a StartTask associated with it, and a request does not specify a StartTask element, then the Pool keeps the existing StartTask. </summary>
        /// <param name="poolId"> The ID of the Pool to update. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTask: {
        ///     commandLine: string (required),
        ///     containerSettings: {
        ///       containerRunOptions: string,
        ///       imageName: string (required),
        ///       registry: {
        ///         username: string,
        ///         password: string,
        ///         registryServer: string,
        ///         identityReference: {
        ///           resourceId: string
        ///         }
        ///       },
        ///       workingDirectory: ContainerWorkingDirectory
        ///     },
        ///     resourceFiles: [
        ///       {
        ///         autoStorageContainerName: string,
        ///         storageContainerUrl: string,
        ///         httpUrl: string,
        ///         blobPrefix: string,
        ///         filePath: string,
        ///         fileMode: string,
        ///         identityReference: ComputeNodeIdentityReference
        ///       }
        ///     ],
        ///     environmentSettings: [
        ///       {
        ///         name: string (required),
        ///         value: string
        ///       }
        ///     ],
        ///     userIdentity: {
        ///       username: string,
        ///       autoUser: {
        ///         scope: AutoUserScope,
        ///         elevationLevel: ElevationLevel
        ///       }
        ///     },
        ///     maxTaskRetryCount: number,
        ///     waitForSuccess: boolean
        ///   },
        ///   certificateReferences: [
        ///     {
        ///       thumbprint: string (required),
        ///       thumbprintAlgorithm: string (required),
        ///       storeLocation: CertificateStoreLocation,
        ///       storeName: string,
        ///       visibility: [CertificateVisibility]
        ///     }
        ///   ],
        ///   applicationPackageReferences: [
        ///     {
        ///       applicationId: string (required),
        ///       version: string
        ///     }
        ///   ],
        ///   metadata: [
        ///     {
        ///       name: string (required),
        ///       value: string (required)
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> PatchAsync(string poolId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.Patch");
            scope.Start();
            try
            {
                using HttpMessage message = CreatePatchRequest(poolId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This only replaces the Pool properties specified in the request. For example, if the Pool has a StartTask associated with it, and a request does not specify a StartTask element, then the Pool keeps the existing StartTask. </summary>
        /// <param name="poolId"> The ID of the Pool to update. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTask: {
        ///     commandLine: string (required),
        ///     containerSettings: {
        ///       containerRunOptions: string,
        ///       imageName: string (required),
        ///       registry: {
        ///         username: string,
        ///         password: string,
        ///         registryServer: string,
        ///         identityReference: {
        ///           resourceId: string
        ///         }
        ///       },
        ///       workingDirectory: ContainerWorkingDirectory
        ///     },
        ///     resourceFiles: [
        ///       {
        ///         autoStorageContainerName: string,
        ///         storageContainerUrl: string,
        ///         httpUrl: string,
        ///         blobPrefix: string,
        ///         filePath: string,
        ///         fileMode: string,
        ///         identityReference: ComputeNodeIdentityReference
        ///       }
        ///     ],
        ///     environmentSettings: [
        ///       {
        ///         name: string (required),
        ///         value: string
        ///       }
        ///     ],
        ///     userIdentity: {
        ///       username: string,
        ///       autoUser: {
        ///         scope: AutoUserScope,
        ///         elevationLevel: ElevationLevel
        ///       }
        ///     },
        ///     maxTaskRetryCount: number,
        ///     waitForSuccess: boolean
        ///   },
        ///   certificateReferences: [
        ///     {
        ///       thumbprint: string (required),
        ///       thumbprintAlgorithm: string (required),
        ///       storeLocation: CertificateStoreLocation,
        ///       storeName: string,
        ///       visibility: [CertificateVisibility]
        ///     }
        ///   ],
        ///   applicationPackageReferences: [
        ///     {
        ///       applicationId: string (required),
        ///       version: string
        ///     }
        ///   ],
        ///   metadata: [
        ///     {
        ///       name: string (required),
        ///       value: string (required)
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response Patch(string poolId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.Patch");
            scope.Start();
            try
            {
                using HttpMessage message = CreatePatchRequest(poolId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Disables automatic scaling for a Pool. </summary>
        /// <param name="poolId"> The ID of the Pool on which to disable automatic scaling. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> DisableAutoScaleAsync(string poolId, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.DisableAutoScale");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDisableAutoScaleRequest(poolId, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Disables automatic scaling for a Pool. </summary>
        /// <param name="poolId"> The ID of the Pool on which to disable automatic scaling. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response DisableAutoScale(string poolId, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.DisableAutoScale");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDisableAutoScaleRequest(poolId, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You cannot enable automatic scaling on a Pool if a resize operation is in progress on the Pool. If automatic scaling of the Pool is currently disabled, you must specify a valid autoscale formula as part of the request. If automatic scaling of the Pool is already enabled, you may specify a new autoscale formula and/or a new evaluation interval. You cannot call this API for the same Pool more than once every 30 seconds. </summary>
        /// <param name="poolId"> The ID of the Pool on which to enable automatic scaling. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   autoScaleFormula: string,
        ///   autoScaleEvaluationInterval: PoolEnableAutoScaleParameterAutoScaleEvaluationInterval
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> EnableAutoScaleAsync(string poolId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.EnableAutoScale");
            scope.Start();
            try
            {
                using HttpMessage message = CreateEnableAutoScaleRequest(poolId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You cannot enable automatic scaling on a Pool if a resize operation is in progress on the Pool. If automatic scaling of the Pool is currently disabled, you must specify a valid autoscale formula as part of the request. If automatic scaling of the Pool is already enabled, you may specify a new autoscale formula and/or a new evaluation interval. You cannot call this API for the same Pool more than once every 30 seconds. </summary>
        /// <param name="poolId"> The ID of the Pool on which to enable automatic scaling. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   autoScaleFormula: string,
        ///   autoScaleEvaluationInterval: PoolEnableAutoScaleParameterAutoScaleEvaluationInterval
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response EnableAutoScale(string poolId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.EnableAutoScale");
            scope.Start();
            try
            {
                using HttpMessage message = CreateEnableAutoScaleRequest(poolId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This API is primarily for validating an autoscale formula, as it simply returns the result without applying the formula to the Pool. The Pool must have auto scaling enabled in order to evaluate a formula. </summary>
        /// <param name="poolId"> The ID of the Pool on which to evaluate the automatic scaling formula. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   autoScaleFormula: string (required)
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   timestamp: string (ISO 8601 Format),
        ///   results: string,
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     values: [
        ///       {
        ///         name: string,
        ///         value: string
        ///       }
        ///     ]
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> EvaluateAutoScaleAsync(string poolId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.EvaluateAutoScale");
            scope.Start();
            try
            {
                using HttpMessage message = CreateEvaluateAutoScaleRequest(poolId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This API is primarily for validating an autoscale formula, as it simply returns the result without applying the formula to the Pool. The Pool must have auto scaling enabled in order to evaluate a formula. </summary>
        /// <param name="poolId"> The ID of the Pool on which to evaluate the automatic scaling formula. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   autoScaleFormula: string (required)
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   timestamp: string (ISO 8601 Format),
        ///   results: string,
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     values: [
        ///       {
        ///         name: string,
        ///         value: string
        ///       }
        ///     ]
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response EvaluateAutoScale(string poolId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.EvaluateAutoScale");
            scope.Start();
            try
            {
                using HttpMessage message = CreateEvaluateAutoScaleRequest(poolId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You can only resize a Pool when its allocation state is steady. If the Pool is already resizing, the request fails with status code 409. When you resize a Pool, the Pool&apos;s allocation state changes from steady to resizing. You cannot resize Pools which are configured for automatic scaling. If you try to do this, the Batch service returns an error 409. If you resize a Pool downwards, the Batch service chooses which Compute Nodes to remove. To remove specific Compute Nodes, use the Pool remove Compute Nodes API instead. </summary>
        /// <param name="poolId"> The ID of the Pool to resize. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   targetDedicatedNodes: number,
        ///   targetLowPriorityNodes: number,
        ///   resizeTimeout: PoolResizeParameterResizeTimeout,
        ///   nodeDeallocationOption: ComputeNodeDeallocationOption
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> ResizeAsync(string poolId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.Resize");
            scope.Start();
            try
            {
                using HttpMessage message = CreateResizeRequest(poolId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You can only resize a Pool when its allocation state is steady. If the Pool is already resizing, the request fails with status code 409. When you resize a Pool, the Pool&apos;s allocation state changes from steady to resizing. You cannot resize Pools which are configured for automatic scaling. If you try to do this, the Batch service returns an error 409. If you resize a Pool downwards, the Batch service chooses which Compute Nodes to remove. To remove specific Compute Nodes, use the Pool remove Compute Nodes API instead. </summary>
        /// <param name="poolId"> The ID of the Pool to resize. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   targetDedicatedNodes: number,
        ///   targetLowPriorityNodes: number,
        ///   resizeTimeout: PoolResizeParameterResizeTimeout,
        ///   nodeDeallocationOption: ComputeNodeDeallocationOption
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response Resize(string poolId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.Resize");
            scope.Start();
            try
            {
                using HttpMessage message = CreateResizeRequest(poolId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This does not restore the Pool to its previous state before the resize operation: it only stops any further changes being made, and the Pool maintains its current state. After stopping, the Pool stabilizes at the number of Compute Nodes it was at when the stop operation was done. During the stop operation, the Pool allocation state changes first to stopping and then to steady. A resize operation need not be an explicit resize Pool request; this API can also be used to halt the initial sizing of the Pool when it is created. </summary>
        /// <param name="poolId"> The ID of the Pool whose resizing you want to stop. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> StopResizeAsync(string poolId, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.StopResize");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStopResizeRequest(poolId, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This does not restore the Pool to its previous state before the resize operation: it only stops any further changes being made, and the Pool maintains its current state. After stopping, the Pool stabilizes at the number of Compute Nodes it was at when the stop operation was done. During the stop operation, the Pool allocation state changes first to stopping and then to steady. A resize operation need not be an explicit resize Pool request; this API can also be used to halt the initial sizing of the Pool when it is created. </summary>
        /// <param name="poolId"> The ID of the Pool whose resizing you want to stop. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response StopResize(string poolId, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.StopResize");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStopResizeRequest(poolId, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This fully replaces all the updatable properties of the Pool. For example, if the Pool has a StartTask associated with it and if StartTask is not specified with this request, then the Batch service will remove the existing StartTask. </summary>
        /// <param name="poolId"> The ID of the Pool to update. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTask: {
        ///     commandLine: string (required),
        ///     containerSettings: {
        ///       containerRunOptions: string,
        ///       imageName: string (required),
        ///       registry: {
        ///         username: string,
        ///         password: string,
        ///         registryServer: string,
        ///         identityReference: {
        ///           resourceId: string
        ///         }
        ///       },
        ///       workingDirectory: ContainerWorkingDirectory
        ///     },
        ///     resourceFiles: [
        ///       {
        ///         autoStorageContainerName: string,
        ///         storageContainerUrl: string,
        ///         httpUrl: string,
        ///         blobPrefix: string,
        ///         filePath: string,
        ///         fileMode: string,
        ///         identityReference: ComputeNodeIdentityReference
        ///       }
        ///     ],
        ///     environmentSettings: [
        ///       {
        ///         name: string (required),
        ///         value: string
        ///       }
        ///     ],
        ///     userIdentity: {
        ///       username: string,
        ///       autoUser: {
        ///         scope: AutoUserScope,
        ///         elevationLevel: ElevationLevel
        ///       }
        ///     },
        ///     maxTaskRetryCount: number,
        ///     waitForSuccess: boolean
        ///   },
        ///   certificateReferences: [
        ///     {
        ///       thumbprint: string (required),
        ///       thumbprintAlgorithm: string (required),
        ///       storeLocation: CertificateStoreLocation,
        ///       storeName: string,
        ///       visibility: [CertificateVisibility]
        ///     }
        ///   ] (required),
        ///   applicationPackageReferences: [
        ///     {
        ///       applicationId: string (required),
        ///       version: string
        ///     }
        ///   ] (required),
        ///   metadata: [
        ///     {
        ///       name: string (required),
        ///       value: string (required)
        ///     }
        ///   ] (required)
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> UpdatePropertiesAsync(string poolId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.UpdateProperties");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePropertiesRequest(poolId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This fully replaces all the updatable properties of the Pool. For example, if the Pool has a StartTask associated with it and if StartTask is not specified with this request, then the Batch service will remove the existing StartTask. </summary>
        /// <param name="poolId"> The ID of the Pool to update. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   startTask: {
        ///     commandLine: string (required),
        ///     containerSettings: {
        ///       containerRunOptions: string,
        ///       imageName: string (required),
        ///       registry: {
        ///         username: string,
        ///         password: string,
        ///         registryServer: string,
        ///         identityReference: {
        ///           resourceId: string
        ///         }
        ///       },
        ///       workingDirectory: ContainerWorkingDirectory
        ///     },
        ///     resourceFiles: [
        ///       {
        ///         autoStorageContainerName: string,
        ///         storageContainerUrl: string,
        ///         httpUrl: string,
        ///         blobPrefix: string,
        ///         filePath: string,
        ///         fileMode: string,
        ///         identityReference: ComputeNodeIdentityReference
        ///       }
        ///     ],
        ///     environmentSettings: [
        ///       {
        ///         name: string (required),
        ///         value: string
        ///       }
        ///     ],
        ///     userIdentity: {
        ///       username: string,
        ///       autoUser: {
        ///         scope: AutoUserScope,
        ///         elevationLevel: ElevationLevel
        ///       }
        ///     },
        ///     maxTaskRetryCount: number,
        ///     waitForSuccess: boolean
        ///   },
        ///   certificateReferences: [
        ///     {
        ///       thumbprint: string (required),
        ///       thumbprintAlgorithm: string (required),
        ///       storeLocation: CertificateStoreLocation,
        ///       storeName: string,
        ///       visibility: [CertificateVisibility]
        ///     }
        ///   ] (required),
        ///   applicationPackageReferences: [
        ///     {
        ///       applicationId: string (required),
        ///       version: string
        ///     }
        ///   ] (required),
        ///   metadata: [
        ///     {
        ///       name: string (required),
        ///       value: string (required)
        ///     }
        ///   ] (required)
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response UpdateProperties(string poolId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.UpdateProperties");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdatePropertiesRequest(poolId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This operation can only run when the allocation state of the Pool is steady. When this operation runs, the allocation state changes from steady to resizing. Each request may remove up to 100 nodes. </summary>
        /// <param name="poolId"> The ID of the Pool from which you want to remove Compute Nodes. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   nodeList: [string] (required),
        ///   resizeTimeout: NodeRemoveParameterResizeTimeout,
        ///   nodeDeallocationOption: ComputeNodeDeallocationOption
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> RemoveNodesAsync(string poolId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.RemoveNodes");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRemoveNodesRequest(poolId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This operation can only run when the allocation state of the Pool is steady. When this operation runs, the allocation state changes from steady to resizing. Each request may remove up to 100 nodes. </summary>
        /// <param name="poolId"> The ID of the Pool from which you want to remove Compute Nodes. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="requestConditions"> The content to send as the request conditions of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   nodeList: [string] (required),
        ///   resizeTimeout: NodeRemoveParameterResizeTimeout,
        ///   nodeDeallocationOption: ComputeNodeDeallocationOption
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response RemoveNodes(string poolId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestConditions requestConditions = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("PoolClient.RemoveNodes");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRemoveNodesRequest(poolId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, requestConditions, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> If you do not specify a $filter clause including a poolId, the response includes all Pools that existed in the Account in the time range of the returned aggregation intervals. If you do not specify a $filter clause including a startTime or endTime these filters default to the start and end times of the last aggregation interval currently available; that is, only the last aggregation interval is returned. </summary>
        /// <param name="startTime"> The earliest time from which to include metrics. This must be at least two and a half hours before the current time. If not specified this defaults to the start time of the last aggregation interval currently available. </param>
        /// <param name="endTime"> The latest time from which to include metrics. This must be at least two hours before the current time. If not specified this defaults to the end time of the last aggregation interval currently available. </param>
        /// <param name="filter"> An OData $filter clause. For more information on constructing this filter, see https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics. </param>
        /// <param name="maxResults"> The maximum number of items to return in the response. A maximum of 1000 results will be returned. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       poolId: string,
        ///       startTime: string (ISO 8601 Format),
        ///       endTime: string (ISO 8601 Format),
        ///       vmSize: string,
        ///       totalCoreHours: number
        ///     }
        ///   ],
        ///   odata.nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetUsageMetricsAsync(DateTimeOffset? startTime = null, DateTimeOffset? endTime = null, string filter = null, int? maxResults = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, "PoolClient.GetUsageMetrics");
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetUsageMetricsRequest(startTime, endTime, filter, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context)
                        : CreateGetUsageMetricsNextPageRequest(nextLink, startTime, endTime, filter, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "odata.nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> If you do not specify a $filter clause including a poolId, the response includes all Pools that existed in the Account in the time range of the returned aggregation intervals. If you do not specify a $filter clause including a startTime or endTime these filters default to the start and end times of the last aggregation interval currently available; that is, only the last aggregation interval is returned. </summary>
        /// <param name="startTime"> The earliest time from which to include metrics. This must be at least two and a half hours before the current time. If not specified this defaults to the start time of the last aggregation interval currently available. </param>
        /// <param name="endTime"> The latest time from which to include metrics. This must be at least two hours before the current time. If not specified this defaults to the end time of the last aggregation interval currently available. </param>
        /// <param name="filter"> An OData $filter clause. For more information on constructing this filter, see https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-account-usage-metrics. </param>
        /// <param name="maxResults"> The maximum number of items to return in the response. A maximum of 1000 results will be returned. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       poolId: string,
        ///       startTime: string (ISO 8601 Format),
        ///       endTime: string (ISO 8601 Format),
        ///       vmSize: string,
        ///       totalCoreHours: number
        ///     }
        ///   ],
        ///   odata.nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetUsageMetrics(DateTimeOffset? startTime = null, DateTimeOffset? endTime = null, string filter = null, int? maxResults = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, "PoolClient.GetUsageMetrics");
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetUsageMetricsRequest(startTime, endTime, filter, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context)
                        : CreateGetUsageMetricsNextPageRequest(nextLink, startTime, endTime, filter, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "odata.nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists all of the Pools in the specified Account. </summary>
        /// <param name="filter"> An OData $filter clause. For more information on constructing this filter, see https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools. </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="maxResults"> The maximum number of items to return in the response. A maximum of 1000 Pools can be returned. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       id: string,
        ///       displayName: string,
        ///       url: string,
        ///       eTag: string,
        ///       lastModified: string (ISO 8601 Format),
        ///       creationTime: string (ISO 8601 Format),
        ///       state: PoolState,
        ///       stateTransitionTime: string (ISO 8601 Format),
        ///       allocationState: AllocationState,
        ///       allocationStateTransitionTime: string (ISO 8601 Format),
        ///       vmSize: string,
        ///       cloudServiceConfiguration: {
        ///         osFamily: string,
        ///         osVersion: string
        ///       },
        ///       virtualMachineConfiguration: {
        ///         imageReference: {
        ///           publisher: string,
        ///           offer: string,
        ///           sku: string,
        ///           version: string,
        ///           virtualMachineImageId: string,
        ///           exactVersion: string
        ///         },
        ///         nodeAgentSKUId: string,
        ///         windowsConfiguration: {
        ///           enableAutomaticUpdates: boolean
        ///         },
        ///         dataDisks: [
        ///           {
        ///             lun: number,
        ///             caching: CachingType,
        ///             diskSizeGB: number,
        ///             storageAccountType: StorageAccountType
        ///           }
        ///         ],
        ///         licenseType: string,
        ///         containerConfiguration: {
        ///           type: ContainerType,
        ///           containerImageNames: [string],
        ///           containerRegistries: [
        ///             {
        ///               username: string,
        ///               password: string,
        ///               registryServer: string,
        ///               identityReference: {
        ///                 resourceId: string
        ///               }
        ///             }
        ///           ]
        ///         },
        ///         diskEncryptionConfiguration: {
        ///           targets: [DiskEncryptionTarget]
        ///         },
        ///         nodePlacementConfiguration: {
        ///           policy: NodePlacementPolicyType
        ///         },
        ///         extensions: [
        ///           {
        ///             name: string,
        ///             publisher: string,
        ///             type: string,
        ///             typeHandlerVersion: string,
        ///             autoUpgradeMinorVersion: boolean,
        ///             settings: AnyObject,
        ///             protectedSettings: AnyObject,
        ///             provisionAfterExtensions: [string]
        ///           }
        ///         ],
        ///         osDisk: {
        ///           ephemeralOSDiskSettings: {
        ///             placement: DiffDiskPlacement
        ///           }
        ///         }
        ///       },
        ///       resizeTimeout: CloudPoolResizeTimeout,
        ///       resizeErrors: [
        ///         {
        ///           code: string,
        ///           message: string,
        ///           values: [
        ///             {
        ///               name: string,
        ///               value: string
        ///             }
        ///           ]
        ///         }
        ///       ],
        ///       currentDedicatedNodes: number,
        ///       currentLowPriorityNodes: number,
        ///       targetDedicatedNodes: number,
        ///       targetLowPriorityNodes: number,
        ///       enableAutoScale: boolean,
        ///       autoScaleFormula: string,
        ///       autoScaleEvaluationInterval: CloudPoolAutoScaleEvaluationInterval,
        ///       autoScaleRun: {
        ///         timestamp: string (ISO 8601 Format),
        ///         results: string,
        ///         error: {
        ///           code: string,
        ///           message: string,
        ///           values: [NameValuePair]
        ///         }
        ///       },
        ///       enableInterNodeCommunication: boolean,
        ///       networkConfiguration: {
        ///         subnetId: string,
        ///         dynamicVNetAssignmentScope: DynamicVNetAssignmentScope,
        ///         endpointConfiguration: {
        ///           inboundNATPools: [
        ///             {
        ///               name: string,
        ///               protocol: InboundEndpointProtocol,
        ///               backendPort: number,
        ///               frontendPortRangeStart: number,
        ///               frontendPortRangeEnd: number,
        ///               networkSecurityGroupRules: [
        ///                 {
        ///                   priority: number,
        ///                   access: NetworkSecurityGroupRuleAccess,
        ///                   sourceAddressPrefix: string,
        ///                   sourcePortRanges: [string]
        ///                 }
        ///               ]
        ///             }
        ///           ]
        ///         },
        ///         publicIPAddressConfiguration: {
        ///           provision: IPAddressProvisioningType,
        ///           ipAddressIds: [string]
        ///         }
        ///       },
        ///       startTask: {
        ///         commandLine: string,
        ///         containerSettings: {
        ///           containerRunOptions: string,
        ///           imageName: string,
        ///           registry: ContainerRegistry,
        ///           workingDirectory: ContainerWorkingDirectory
        ///         },
        ///         resourceFiles: [
        ///           {
        ///             autoStorageContainerName: string,
        ///             storageContainerUrl: string,
        ///             httpUrl: string,
        ///             blobPrefix: string,
        ///             filePath: string,
        ///             fileMode: string,
        ///             identityReference: ComputeNodeIdentityReference
        ///           }
        ///         ],
        ///         environmentSettings: [
        ///           {
        ///             name: string,
        ///             value: string
        ///           }
        ///         ],
        ///         userIdentity: {
        ///           username: string,
        ///           autoUser: {
        ///             scope: AutoUserScope,
        ///             elevationLevel: ElevationLevel
        ///           }
        ///         },
        ///         maxTaskRetryCount: number,
        ///         waitForSuccess: boolean
        ///       },
        ///       certificateReferences: [
        ///         {
        ///           thumbprint: string,
        ///           thumbprintAlgorithm: string,
        ///           storeLocation: CertificateStoreLocation,
        ///           storeName: string,
        ///           visibility: [CertificateVisibility]
        ///         }
        ///       ],
        ///       applicationPackageReferences: [
        ///         {
        ///           applicationId: string,
        ///           version: string
        ///         }
        ///       ],
        ///       applicationLicenses: [string],
        ///       taskSlotsPerNode: number,
        ///       taskSchedulingPolicy: {
        ///         nodeFillType: ComputeNodeFillType
        ///       },
        ///       userAccounts: [
        ///         {
        ///           name: string,
        ///           password: string,
        ///           elevationLevel: ElevationLevel,
        ///           linuxUserConfiguration: {
        ///             uid: number,
        ///             gid: number,
        ///             sshPrivateKey: string
        ///           },
        ///           windowsUserConfiguration: {
        ///             loginMode: LoginMode
        ///           }
        ///         }
        ///       ],
        ///       metadata: [
        ///         {
        ///           name: string,
        ///           value: string
        ///         }
        ///       ],
        ///       stats: {
        ///         url: string,
        ///         startTime: string (ISO 8601 Format),
        ///         lastUpdateTime: string (ISO 8601 Format),
        ///         usageStats: {
        ///           startTime: string (ISO 8601 Format),
        ///           lastUpdateTime: string (ISO 8601 Format),
        ///           dedicatedCoreTime: UsageStatisticsDedicatedCoreTime
        ///         },
        ///         resourceStats: {
        ///           startTime: string (ISO 8601 Format),
        ///           lastUpdateTime: string (ISO 8601 Format),
        ///           avgCPUPercentage: number,
        ///           avgMemoryGiB: number,
        ///           peakMemoryGiB: number,
        ///           avgDiskGiB: number,
        ///           peakDiskGiB: number,
        ///           diskReadIOps: number,
        ///           diskWriteIOps: number,
        ///           diskReadGiB: number,
        ///           diskWriteGiB: number,
        ///           networkReadGiB: number,
        ///           networkWriteGiB: number
        ///         }
        ///       },
        ///       mountConfiguration: [
        ///         {
        ///           azureBlobFileSystemConfiguration: {
        ///             accountName: string,
        ///             containerName: string,
        ///             accountKey: string,
        ///             sasKey: string,
        ///             blobfuseOptions: string,
        ///             relativeMountPath: string,
        ///             identityReference: ComputeNodeIdentityReference
        ///           },
        ///           nfsMountConfiguration: {
        ///             source: string,
        ///             relativeMountPath: string,
        ///             mountOptions: string
        ///           },
        ///           cifsMountConfiguration: {
        ///             username: string,
        ///             source: string,
        ///             relativeMountPath: string,
        ///             mountOptions: string,
        ///             password: string
        ///           },
        ///           azureFileShareConfiguration: {
        ///             accountName: string,
        ///             azureFileUrl: string,
        ///             accountKey: string,
        ///             relativeMountPath: string,
        ///             mountOptions: string
        ///           }
        ///         }
        ///       ],
        ///       identity: {
        ///         type: PoolIdentityType,
        ///         userAssignedIdentities: [
        ///           {
        ///             resourceId: string,
        ///             clientId: string,
        ///             principalId: string
        ///           }
        ///         ]
        ///       }
        ///     }
        ///   ],
        ///   odata.nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetPoolsAsync(string filter = null, string select = null, string expand = null, int? maxResults = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, "PoolClient.GetPools");
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetPoolsRequest(filter, select, expand, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context)
                        : CreateGetPoolsNextPageRequest(nextLink, filter, select, expand, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "odata.nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists all of the Pools in the specified Account. </summary>
        /// <param name="filter"> An OData $filter clause. For more information on constructing this filter, see https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-pools. </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="expand"> An OData $expand clause. </param>
        /// <param name="maxResults"> The maximum number of items to return in the response. A maximum of 1000 Pools can be returned. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       id: string,
        ///       displayName: string,
        ///       url: string,
        ///       eTag: string,
        ///       lastModified: string (ISO 8601 Format),
        ///       creationTime: string (ISO 8601 Format),
        ///       state: PoolState,
        ///       stateTransitionTime: string (ISO 8601 Format),
        ///       allocationState: AllocationState,
        ///       allocationStateTransitionTime: string (ISO 8601 Format),
        ///       vmSize: string,
        ///       cloudServiceConfiguration: {
        ///         osFamily: string,
        ///         osVersion: string
        ///       },
        ///       virtualMachineConfiguration: {
        ///         imageReference: {
        ///           publisher: string,
        ///           offer: string,
        ///           sku: string,
        ///           version: string,
        ///           virtualMachineImageId: string,
        ///           exactVersion: string
        ///         },
        ///         nodeAgentSKUId: string,
        ///         windowsConfiguration: {
        ///           enableAutomaticUpdates: boolean
        ///         },
        ///         dataDisks: [
        ///           {
        ///             lun: number,
        ///             caching: CachingType,
        ///             diskSizeGB: number,
        ///             storageAccountType: StorageAccountType
        ///           }
        ///         ],
        ///         licenseType: string,
        ///         containerConfiguration: {
        ///           type: ContainerType,
        ///           containerImageNames: [string],
        ///           containerRegistries: [
        ///             {
        ///               username: string,
        ///               password: string,
        ///               registryServer: string,
        ///               identityReference: {
        ///                 resourceId: string
        ///               }
        ///             }
        ///           ]
        ///         },
        ///         diskEncryptionConfiguration: {
        ///           targets: [DiskEncryptionTarget]
        ///         },
        ///         nodePlacementConfiguration: {
        ///           policy: NodePlacementPolicyType
        ///         },
        ///         extensions: [
        ///           {
        ///             name: string,
        ///             publisher: string,
        ///             type: string,
        ///             typeHandlerVersion: string,
        ///             autoUpgradeMinorVersion: boolean,
        ///             settings: AnyObject,
        ///             protectedSettings: AnyObject,
        ///             provisionAfterExtensions: [string]
        ///           }
        ///         ],
        ///         osDisk: {
        ///           ephemeralOSDiskSettings: {
        ///             placement: DiffDiskPlacement
        ///           }
        ///         }
        ///       },
        ///       resizeTimeout: CloudPoolResizeTimeout,
        ///       resizeErrors: [
        ///         {
        ///           code: string,
        ///           message: string,
        ///           values: [
        ///             {
        ///               name: string,
        ///               value: string
        ///             }
        ///           ]
        ///         }
        ///       ],
        ///       currentDedicatedNodes: number,
        ///       currentLowPriorityNodes: number,
        ///       targetDedicatedNodes: number,
        ///       targetLowPriorityNodes: number,
        ///       enableAutoScale: boolean,
        ///       autoScaleFormula: string,
        ///       autoScaleEvaluationInterval: CloudPoolAutoScaleEvaluationInterval,
        ///       autoScaleRun: {
        ///         timestamp: string (ISO 8601 Format),
        ///         results: string,
        ///         error: {
        ///           code: string,
        ///           message: string,
        ///           values: [NameValuePair]
        ///         }
        ///       },
        ///       enableInterNodeCommunication: boolean,
        ///       networkConfiguration: {
        ///         subnetId: string,
        ///         dynamicVNetAssignmentScope: DynamicVNetAssignmentScope,
        ///         endpointConfiguration: {
        ///           inboundNATPools: [
        ///             {
        ///               name: string,
        ///               protocol: InboundEndpointProtocol,
        ///               backendPort: number,
        ///               frontendPortRangeStart: number,
        ///               frontendPortRangeEnd: number,
        ///               networkSecurityGroupRules: [
        ///                 {
        ///                   priority: number,
        ///                   access: NetworkSecurityGroupRuleAccess,
        ///                   sourceAddressPrefix: string,
        ///                   sourcePortRanges: [string]
        ///                 }
        ///               ]
        ///             }
        ///           ]
        ///         },
        ///         publicIPAddressConfiguration: {
        ///           provision: IPAddressProvisioningType,
        ///           ipAddressIds: [string]
        ///         }
        ///       },
        ///       startTask: {
        ///         commandLine: string,
        ///         containerSettings: {
        ///           containerRunOptions: string,
        ///           imageName: string,
        ///           registry: ContainerRegistry,
        ///           workingDirectory: ContainerWorkingDirectory
        ///         },
        ///         resourceFiles: [
        ///           {
        ///             autoStorageContainerName: string,
        ///             storageContainerUrl: string,
        ///             httpUrl: string,
        ///             blobPrefix: string,
        ///             filePath: string,
        ///             fileMode: string,
        ///             identityReference: ComputeNodeIdentityReference
        ///           }
        ///         ],
        ///         environmentSettings: [
        ///           {
        ///             name: string,
        ///             value: string
        ///           }
        ///         ],
        ///         userIdentity: {
        ///           username: string,
        ///           autoUser: {
        ///             scope: AutoUserScope,
        ///             elevationLevel: ElevationLevel
        ///           }
        ///         },
        ///         maxTaskRetryCount: number,
        ///         waitForSuccess: boolean
        ///       },
        ///       certificateReferences: [
        ///         {
        ///           thumbprint: string,
        ///           thumbprintAlgorithm: string,
        ///           storeLocation: CertificateStoreLocation,
        ///           storeName: string,
        ///           visibility: [CertificateVisibility]
        ///         }
        ///       ],
        ///       applicationPackageReferences: [
        ///         {
        ///           applicationId: string,
        ///           version: string
        ///         }
        ///       ],
        ///       applicationLicenses: [string],
        ///       taskSlotsPerNode: number,
        ///       taskSchedulingPolicy: {
        ///         nodeFillType: ComputeNodeFillType
        ///       },
        ///       userAccounts: [
        ///         {
        ///           name: string,
        ///           password: string,
        ///           elevationLevel: ElevationLevel,
        ///           linuxUserConfiguration: {
        ///             uid: number,
        ///             gid: number,
        ///             sshPrivateKey: string
        ///           },
        ///           windowsUserConfiguration: {
        ///             loginMode: LoginMode
        ///           }
        ///         }
        ///       ],
        ///       metadata: [
        ///         {
        ///           name: string,
        ///           value: string
        ///         }
        ///       ],
        ///       stats: {
        ///         url: string,
        ///         startTime: string (ISO 8601 Format),
        ///         lastUpdateTime: string (ISO 8601 Format),
        ///         usageStats: {
        ///           startTime: string (ISO 8601 Format),
        ///           lastUpdateTime: string (ISO 8601 Format),
        ///           dedicatedCoreTime: UsageStatisticsDedicatedCoreTime
        ///         },
        ///         resourceStats: {
        ///           startTime: string (ISO 8601 Format),
        ///           lastUpdateTime: string (ISO 8601 Format),
        ///           avgCPUPercentage: number,
        ///           avgMemoryGiB: number,
        ///           peakMemoryGiB: number,
        ///           avgDiskGiB: number,
        ///           peakDiskGiB: number,
        ///           diskReadIOps: number,
        ///           diskWriteIOps: number,
        ///           diskReadGiB: number,
        ///           diskWriteGiB: number,
        ///           networkReadGiB: number,
        ///           networkWriteGiB: number
        ///         }
        ///       },
        ///       mountConfiguration: [
        ///         {
        ///           azureBlobFileSystemConfiguration: {
        ///             accountName: string,
        ///             containerName: string,
        ///             accountKey: string,
        ///             sasKey: string,
        ///             blobfuseOptions: string,
        ///             relativeMountPath: string,
        ///             identityReference: ComputeNodeIdentityReference
        ///           },
        ///           nfsMountConfiguration: {
        ///             source: string,
        ///             relativeMountPath: string,
        ///             mountOptions: string
        ///           },
        ///           cifsMountConfiguration: {
        ///             username: string,
        ///             source: string,
        ///             relativeMountPath: string,
        ///             mountOptions: string,
        ///             password: string
        ///           },
        ///           azureFileShareConfiguration: {
        ///             accountName: string,
        ///             azureFileUrl: string,
        ///             accountKey: string,
        ///             relativeMountPath: string,
        ///             mountOptions: string
        ///           }
        ///         }
        ///       ],
        ///       identity: {
        ///         type: PoolIdentityType,
        ///         userAssignedIdentities: [
        ///           {
        ///             resourceId: string,
        ///             clientId: string,
        ///             principalId: string
        ///           }
        ///         ]
        ///       }
        ///     }
        ///   ],
        ///   odata.nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetPools(string filter = null, string select = null, string expand = null, int? maxResults = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, "PoolClient.GetPools");
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetPoolsRequest(filter, select, expand, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context)
                        : CreateGetPoolsNextPageRequest(nextLink, filter, select, expand, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "odata.nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        internal HttpMessage CreateGetUsageMetricsRequest(DateTimeOffset? startTime, DateTimeOffset? endTime, string filter, int? maxResults, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/poolusagemetrics", false);
            if (startTime != null)
            {
                uri.AppendQuery("starttime", startTime.Value, "O", true);
            }
            if (endTime != null)
            {
                uri.AppendQuery("endtime", endTime.Value, "O", true);
            }
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            if (maxResults != null)
            {
                uri.AppendQuery("maxresults", maxResults.Value, true);
            }
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetAllLifetimeStatisticsRequest(int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/lifetimepoolstats", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateAddRequest(RequestContent content, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetPoolsRequest(string filter, string select, string expand, int? maxResults, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools", false);
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            if (select != null)
            {
                uri.AppendQuery("$select", select, true);
            }
            if (expand != null)
            {
                uri.AppendQuery("$expand", expand, true);
            }
            if (maxResults != null)
            {
                uri.AppendQuery("maxresults", maxResults.Value, true);
            }
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteRequest(string poolId, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateExistsRequest(string poolId, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200404);
            var request = message.Request;
            request.Method = RequestMethod.Head;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateGetPoolRequest(string poolId, string select, string expand, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            if (select != null)
            {
                uri.AppendQuery("$select", select, true);
            }
            if (expand != null)
            {
                uri.AppendQuery("$expand", expand, true);
            }
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreatePatchRequest(string poolId, RequestContent content, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDisableAutoScaleRequest(string poolId, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/disableautoscale", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateEnableAutoScaleRequest(string poolId, RequestContent content, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/enableautoscale", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateEvaluateAutoScaleRequest(string poolId, RequestContent content, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/evaluateautoscale", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateResizeRequest(string poolId, RequestContent content, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/resize", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateStopResizeRequest(string poolId, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/stopresize", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            return message;
        }

        internal HttpMessage CreateUpdatePropertiesRequest(string poolId, RequestContent content, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/updateproperties", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateRemoveNodesRequest(string poolId, RequestContent content, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestConditions requestConditions, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/removenodes", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            if (requestConditions != null)
            {
                request.Headers.Add(requestConditions, "R");
            }
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetUsageMetricsNextPageRequest(string nextLink, DateTimeOffset? startTime, DateTimeOffset? endTime, string filter, int? maxResults, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetPoolsNextPageRequest(string nextLink, string filter, string select, string expand, int? maxResults, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier201;
        private static ResponseClassifier ResponseClassifier201 => _responseClassifier201 ??= new StatusCodeClassifier(stackalloc ushort[] { 201 });
        private static ResponseClassifier _responseClassifier202;
        private static ResponseClassifier ResponseClassifier202 => _responseClassifier202 ??= new StatusCodeClassifier(stackalloc ushort[] { 202 });
        private static ResponseClassifier _responseClassifier200404;
        private static ResponseClassifier ResponseClassifier200404 => _responseClassifier200404 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 404 });
        private static ResponseClassifier _responseClassifier204;
        private static ResponseClassifier ResponseClassifier204 => _responseClassifier204 ??= new StatusCodeClassifier(stackalloc ushort[] { 204 });
    }
}
