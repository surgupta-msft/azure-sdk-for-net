// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.Data.Batch
{
    /// <summary> The ComputeNode service client. </summary>
    public partial class ComputeNodeClient
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://batch.core.windows.net/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly string _batchUrl;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of ComputeNodeClient for mocking. </summary>
        protected ComputeNodeClient()
        {
        }

        /// <summary> Initializes a new instance of ComputeNodeClient. </summary>
        /// <param name="batchUrl"> The base URL for all Azure Batch service requests. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="batchUrl"/> or <paramref name="credential"/> is null. </exception>
        public ComputeNodeClient(string batchUrl, TokenCredential credential, AzureBatchClientOptions options = null)
        {
            Argument.AssertNotNull(batchUrl, nameof(batchUrl));
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new AzureBatchClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options);
            _tokenCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential, AuthorizationScopes) }, new ResponseClassifier());
            _batchUrl = batchUrl;
            _apiVersion = options.Version;
        }

        /// <summary> You can add a user Account to a Compute Node only when it is in the idle or running state. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to create a user Account. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   name: string (required),
        ///   isAdmin: boolean,
        ///   expiryTime: string (ISO 8601 Format),
        ///   password: string,
        ///   sshPublicKey: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> AddUserAsync(string poolId, string nodeId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeClient.AddUser");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddUserRequest(poolId, nodeId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You can add a user Account to a Compute Node only when it is in the idle or running state. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to create a user Account. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   name: string (required),
        ///   isAdmin: boolean,
        ///   expiryTime: string (ISO 8601 Format),
        ///   password: string,
        ///   sshPublicKey: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response AddUser(string poolId, string nodeId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeClient.AddUser");
            scope.Start();
            try
            {
                using HttpMessage message = CreateAddUserRequest(poolId, nodeId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You can delete a user Account to a Compute Node only when it is in the idle or running state. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to delete a user Account. </param>
        /// <param name="userName"> The name of the user Account to delete. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="userName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="userName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> DeleteUserAsync(string poolId, string nodeId, string userName, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(userName, nameof(userName));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeClient.DeleteUser");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteUserRequest(poolId, nodeId, userName, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You can delete a user Account to a Compute Node only when it is in the idle or running state. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to delete a user Account. </param>
        /// <param name="userName"> The name of the user Account to delete. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="userName"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="userName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response DeleteUser(string poolId, string nodeId, string userName, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(userName, nameof(userName));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeClient.DeleteUser");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteUserRequest(poolId, nodeId, userName, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This operation replaces of all the updatable properties of the Account. For example, if the expiryTime element is not specified, the current value is replaced with the default value, not left unmodified. You can update a user Account on a Compute Node only when it is in the idle or running state. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to update a user Account. </param>
        /// <param name="userName"> The name of the user Account to update. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/>, <paramref name="userName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="userName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   password: string,
        ///   expiryTime: string (ISO 8601 Format),
        ///   sshPublicKey: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> UpdateUserAsync(string poolId, string nodeId, string userName, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(userName, nameof(userName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeClient.UpdateUser");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateUserRequest(poolId, nodeId, userName, content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This operation replaces of all the updatable properties of the Account. For example, if the expiryTime element is not specified, the current value is replaced with the default value, not left unmodified. You can update a user Account on a Compute Node only when it is in the idle or running state. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the machine on which you want to update a user Account. </param>
        /// <param name="userName"> The name of the user Account to update. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/>, <paramref name="userName"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="userName"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   password: string,
        ///   expiryTime: string (ISO 8601 Format),
        ///   sshPublicKey: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response UpdateUser(string poolId, string nodeId, string userName, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNullOrEmpty(userName, nameof(userName));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeClient.UpdateUser");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateUserRequest(poolId, nodeId, userName, content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets information about the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to get information about. </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   id: string,
        ///   url: string,
        ///   state: ComputeNodeState,
        ///   schedulingState: SchedulingState,
        ///   stateTransitionTime: string (ISO 8601 Format),
        ///   lastBootTime: string (ISO 8601 Format),
        ///   allocationTime: string (ISO 8601 Format),
        ///   ipAddress: string,
        ///   affinityId: string,
        ///   vmSize: string,
        ///   totalTasksRun: number,
        ///   runningTasksCount: number,
        ///   runningTaskSlotsCount: number,
        ///   totalTasksSucceeded: number,
        ///   recentTasks: [
        ///     {
        ///       taskUrl: string,
        ///       jobId: string,
        ///       taskId: string,
        ///       subtaskId: number,
        ///       taskState: TaskState,
        ///       executionInfo: {
        ///         startTime: string (ISO 8601 Format),
        ///         endTime: string (ISO 8601 Format),
        ///         exitCode: number,
        ///         containerInfo: {
        ///           containerId: string,
        ///           state: string,
        ///           error: string
        ///         },
        ///         failureInfo: {
        ///           category: ErrorCategory,
        ///           code: string,
        ///           message: string,
        ///           details: [
        ///             {
        ///               name: string,
        ///               value: string
        ///             }
        ///           ]
        ///         },
        ///         retryCount: number,
        ///         lastRetryTime: string (ISO 8601 Format),
        ///         requeueCount: number,
        ///         lastRequeueTime: string (ISO 8601 Format),
        ///         result: TaskExecutionResult
        ///       }
        ///     }
        ///   ],
        ///   startTask: {
        ///     commandLine: string,
        ///     containerSettings: {
        ///       containerRunOptions: string,
        ///       imageName: string,
        ///       registry: {
        ///         username: string,
        ///         password: string,
        ///         registryServer: string,
        ///         identityReference: {
        ///           resourceId: string
        ///         }
        ///       },
        ///       workingDirectory: ContainerWorkingDirectory
        ///     },
        ///     resourceFiles: [
        ///       {
        ///         autoStorageContainerName: string,
        ///         storageContainerUrl: string,
        ///         httpUrl: string,
        ///         blobPrefix: string,
        ///         filePath: string,
        ///         fileMode: string,
        ///         identityReference: ComputeNodeIdentityReference
        ///       }
        ///     ],
        ///     environmentSettings: [
        ///       {
        ///         name: string,
        ///         value: string
        ///       }
        ///     ],
        ///     userIdentity: {
        ///       username: string,
        ///       autoUser: {
        ///         scope: AutoUserScope,
        ///         elevationLevel: ElevationLevel
        ///       }
        ///     },
        ///     maxTaskRetryCount: number,
        ///     waitForSuccess: boolean
        ///   },
        ///   startTaskInfo: {
        ///     state: StartTaskState,
        ///     startTime: string (ISO 8601 Format),
        ///     endTime: string (ISO 8601 Format),
        ///     exitCode: number,
        ///     containerInfo: TaskContainerExecutionInformation,
        ///     failureInfo: TaskFailureInformation,
        ///     retryCount: number,
        ///     lastRetryTime: string (ISO 8601 Format),
        ///     result: TaskExecutionResult
        ///   },
        ///   certificateReferences: [
        ///     {
        ///       thumbprint: string,
        ///       thumbprintAlgorithm: string,
        ///       storeLocation: CertificateStoreLocation,
        ///       storeName: string,
        ///       visibility: [CertificateVisibility]
        ///     }
        ///   ],
        ///   errors: [
        ///     {
        ///       code: string,
        ///       message: string,
        ///       errorDetails: [NameValuePair]
        ///     }
        ///   ],
        ///   isDedicated: boolean,
        ///   endpointConfiguration: {
        ///     inboundEndpoints: [
        ///       {
        ///         name: string,
        ///         protocol: InboundEndpointProtocol,
        ///         publicIPAddress: string,
        ///         publicFQDN: string,
        ///         frontendPort: number,
        ///         backendPort: number
        ///       }
        ///     ]
        ///   },
        ///   nodeAgentInfo: {
        ///     version: string,
        ///     lastUpdateTime: string (ISO 8601 Format)
        ///   },
        ///   virtualMachineInfo: {
        ///     imageReference: {
        ///       publisher: string,
        ///       offer: string,
        ///       sku: string,
        ///       version: string,
        ///       virtualMachineImageId: string,
        ///       exactVersion: string
        ///     }
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetComputeNodeAsync(string poolId, string nodeId, string select = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeClient.GetComputeNode");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetComputeNodeRequest(poolId, nodeId, select, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets information about the specified Compute Node. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to get information about. </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   id: string,
        ///   url: string,
        ///   state: ComputeNodeState,
        ///   schedulingState: SchedulingState,
        ///   stateTransitionTime: string (ISO 8601 Format),
        ///   lastBootTime: string (ISO 8601 Format),
        ///   allocationTime: string (ISO 8601 Format),
        ///   ipAddress: string,
        ///   affinityId: string,
        ///   vmSize: string,
        ///   totalTasksRun: number,
        ///   runningTasksCount: number,
        ///   runningTaskSlotsCount: number,
        ///   totalTasksSucceeded: number,
        ///   recentTasks: [
        ///     {
        ///       taskUrl: string,
        ///       jobId: string,
        ///       taskId: string,
        ///       subtaskId: number,
        ///       taskState: TaskState,
        ///       executionInfo: {
        ///         startTime: string (ISO 8601 Format),
        ///         endTime: string (ISO 8601 Format),
        ///         exitCode: number,
        ///         containerInfo: {
        ///           containerId: string,
        ///           state: string,
        ///           error: string
        ///         },
        ///         failureInfo: {
        ///           category: ErrorCategory,
        ///           code: string,
        ///           message: string,
        ///           details: [
        ///             {
        ///               name: string,
        ///               value: string
        ///             }
        ///           ]
        ///         },
        ///         retryCount: number,
        ///         lastRetryTime: string (ISO 8601 Format),
        ///         requeueCount: number,
        ///         lastRequeueTime: string (ISO 8601 Format),
        ///         result: TaskExecutionResult
        ///       }
        ///     }
        ///   ],
        ///   startTask: {
        ///     commandLine: string,
        ///     containerSettings: {
        ///       containerRunOptions: string,
        ///       imageName: string,
        ///       registry: {
        ///         username: string,
        ///         password: string,
        ///         registryServer: string,
        ///         identityReference: {
        ///           resourceId: string
        ///         }
        ///       },
        ///       workingDirectory: ContainerWorkingDirectory
        ///     },
        ///     resourceFiles: [
        ///       {
        ///         autoStorageContainerName: string,
        ///         storageContainerUrl: string,
        ///         httpUrl: string,
        ///         blobPrefix: string,
        ///         filePath: string,
        ///         fileMode: string,
        ///         identityReference: ComputeNodeIdentityReference
        ///       }
        ///     ],
        ///     environmentSettings: [
        ///       {
        ///         name: string,
        ///         value: string
        ///       }
        ///     ],
        ///     userIdentity: {
        ///       username: string,
        ///       autoUser: {
        ///         scope: AutoUserScope,
        ///         elevationLevel: ElevationLevel
        ///       }
        ///     },
        ///     maxTaskRetryCount: number,
        ///     waitForSuccess: boolean
        ///   },
        ///   startTaskInfo: {
        ///     state: StartTaskState,
        ///     startTime: string (ISO 8601 Format),
        ///     endTime: string (ISO 8601 Format),
        ///     exitCode: number,
        ///     containerInfo: TaskContainerExecutionInformation,
        ///     failureInfo: TaskFailureInformation,
        ///     retryCount: number,
        ///     lastRetryTime: string (ISO 8601 Format),
        ///     result: TaskExecutionResult
        ///   },
        ///   certificateReferences: [
        ///     {
        ///       thumbprint: string,
        ///       thumbprintAlgorithm: string,
        ///       storeLocation: CertificateStoreLocation,
        ///       storeName: string,
        ///       visibility: [CertificateVisibility]
        ///     }
        ///   ],
        ///   errors: [
        ///     {
        ///       code: string,
        ///       message: string,
        ///       errorDetails: [NameValuePair]
        ///     }
        ///   ],
        ///   isDedicated: boolean,
        ///   endpointConfiguration: {
        ///     inboundEndpoints: [
        ///       {
        ///         name: string,
        ///         protocol: InboundEndpointProtocol,
        ///         publicIPAddress: string,
        ///         publicFQDN: string,
        ///         frontendPort: number,
        ///         backendPort: number
        ///       }
        ///     ]
        ///   },
        ///   nodeAgentInfo: {
        ///     version: string,
        ///     lastUpdateTime: string (ISO 8601 Format)
        ///   },
        ///   virtualMachineInfo: {
        ///     imageReference: {
        ///       publisher: string,
        ///       offer: string,
        ///       sku: string,
        ///       version: string,
        ///       virtualMachineImageId: string,
        ///       exactVersion: string
        ///     }
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetComputeNode(string poolId, string nodeId, string select = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeClient.GetComputeNode");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetComputeNodeRequest(poolId, nodeId, select, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You can restart a Compute Node only if it is in an idle or running state. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   nodeRebootOption: ComputeNodeRebootOption
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> RebootAsync(string poolId, string nodeId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeClient.Reboot");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRebootRequest(poolId, nodeId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You can restart a Compute Node only if it is in an idle or running state. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   nodeRebootOption: ComputeNodeRebootOption
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response Reboot(string poolId, string nodeId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeClient.Reboot");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRebootRequest(poolId, nodeId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You can reinstall the operating system on a Compute Node only if it is in an idle or running state. This API can be invoked only on Pools created with the cloud service configuration property. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   nodeReimageOption: ComputeNodeReimageOption
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> ReimageAsync(string poolId, string nodeId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeClient.Reimage");
            scope.Start();
            try
            {
                using HttpMessage message = CreateReimageRequest(poolId, nodeId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You can reinstall the operating system on a Compute Node only if it is in an idle or running state. This API can be invoked only on Pools created with the cloud service configuration property. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node that you want to restart. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   nodeReimageOption: ComputeNodeReimageOption
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response Reimage(string poolId, string nodeId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeClient.Reimage");
            scope.Start();
            try
            {
                using HttpMessage message = CreateReimageRequest(poolId, nodeId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You can disable Task scheduling on a Compute Node only if its current scheduling state is enabled. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node on which you want to disable Task scheduling. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   nodeDisableSchedulingOption: DisableComputeNodeSchedulingOption
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> DisableSchedulingAsync(string poolId, string nodeId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeClient.DisableScheduling");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDisableSchedulingRequest(poolId, nodeId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You can disable Task scheduling on a Compute Node only if its current scheduling state is enabled. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node on which you want to disable Task scheduling. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   nodeDisableSchedulingOption: DisableComputeNodeSchedulingOption
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response DisableScheduling(string poolId, string nodeId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeClient.DisableScheduling");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDisableSchedulingRequest(poolId, nodeId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You can enable Task scheduling on a Compute Node only if its current scheduling state is disabled. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node on which you want to enable Task scheduling. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> EnableSchedulingAsync(string poolId, string nodeId, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeClient.EnableScheduling");
            scope.Start();
            try
            {
                using HttpMessage message = CreateEnableSchedulingRequest(poolId, nodeId, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> You can enable Task scheduling on a Compute Node only if its current scheduling state is disabled. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node on which you want to enable Task scheduling. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response EnableScheduling(string poolId, string nodeId, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeClient.EnableScheduling");
            scope.Start();
            try
            {
                using HttpMessage message = CreateEnableSchedulingRequest(poolId, nodeId, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Before you can remotely login to a Compute Node using the remote login settings, you must create a user Account on the Compute Node. This API can be invoked only on Pools created with the virtual machine configuration property. For Pools created with a cloud service configuration, see the GetRemoteDesktop API. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node for which to obtain the remote login settings. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   remoteLoginIPAddress: string,
        ///   remoteLoginPort: number
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetRemoteLoginSettingsAsync(string poolId, string nodeId, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeClient.GetRemoteLoginSettings");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetRemoteLoginSettingsRequest(poolId, nodeId, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Before you can remotely login to a Compute Node using the remote login settings, you must create a user Account on the Compute Node. This API can be invoked only on Pools created with the virtual machine configuration property. For Pools created with a cloud service configuration, see the GetRemoteDesktop API. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node for which to obtain the remote login settings. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   remoteLoginIPAddress: string,
        ///   remoteLoginPort: number
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetRemoteLoginSettings(string poolId, string nodeId, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeClient.GetRemoteLoginSettings");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetRemoteLoginSettingsRequest(poolId, nodeId, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Before you can access a Compute Node by using the RDP file, you must create a user Account on the Compute Node. This API can only be invoked on Pools created with a cloud service configuration. For Pools created with a virtual machine configuration, see the GetRemoteLoginSettings API. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node for which you want to get the Remote Desktop Protocol file. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetRemoteDesktopAsync(string poolId, string nodeId, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeClient.GetRemoteDesktop");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetRemoteDesktopRequest(poolId, nodeId, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Before you can access a Compute Node by using the RDP file, you must create a user Account on the Compute Node. This API can only be invoked on Pools created with a cloud service configuration. For Pools created with a virtual machine configuration, see the GetRemoteLoginSettings API. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node for which you want to get the Remote Desktop Protocol file. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetRemoteDesktop(string poolId, string nodeId, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeClient.GetRemoteDesktop");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetRemoteDesktopRequest(poolId, nodeId, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This is for gathering Azure Batch service log files in an automated fashion from Compute Nodes if you are experiencing an error and wish to escalate to Azure support. The Azure Batch service log files should be shared with Azure support to aid in debugging issues with the Batch service. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node from which you want to upload the Azure Batch service log files. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   containerUrl: string (required),
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format),
        ///   identityReference: {
        ///     resourceId: string
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   virtualDirectoryName: string,
        ///   numberOfFilesUploaded: number
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> UploadBatchServiceLogsAsync(string poolId, string nodeId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeClient.UploadBatchServiceLogs");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUploadBatchServiceLogsRequest(poolId, nodeId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> This is for gathering Azure Batch service log files in an automated fashion from Compute Nodes if you are experiencing an error and wish to escalate to Azure support. The Azure Batch service log files should be shared with Azure support to aid in debugging issues with the Batch service. </summary>
        /// <param name="poolId"> The ID of the Pool that contains the Compute Node. </param>
        /// <param name="nodeId"> The ID of the Compute Node from which you want to upload the Azure Batch service log files. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/>, <paramref name="nodeId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> or <paramref name="nodeId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   containerUrl: string (required),
        ///   startTime: string (ISO 8601 Format) (required),
        ///   endTime: string (ISO 8601 Format),
        ///   identityReference: {
        ///     resourceId: string
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   virtualDirectoryName: string,
        ///   numberOfFilesUploaded: number
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response UploadBatchServiceLogs(string poolId, string nodeId, RequestContent content, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));
            Argument.AssertNotNullOrEmpty(nodeId, nameof(nodeId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("ComputeNodeClient.UploadBatchServiceLogs");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUploadBatchServiceLogsRequest(poolId, nodeId, content, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Lists the Compute Nodes in the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool from which you want to list Compute Nodes. </param>
        /// <param name="filter"> An OData $filter clause. For more information on constructing this filter, see https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-nodes-in-a-pool. </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="maxResults"> The maximum number of items to return in the response. A maximum of 1000 Compute Nodes can be returned. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       id: string,
        ///       url: string,
        ///       state: ComputeNodeState,
        ///       schedulingState: SchedulingState,
        ///       stateTransitionTime: string (ISO 8601 Format),
        ///       lastBootTime: string (ISO 8601 Format),
        ///       allocationTime: string (ISO 8601 Format),
        ///       ipAddress: string,
        ///       affinityId: string,
        ///       vmSize: string,
        ///       totalTasksRun: number,
        ///       runningTasksCount: number,
        ///       runningTaskSlotsCount: number,
        ///       totalTasksSucceeded: number,
        ///       recentTasks: [
        ///         {
        ///           taskUrl: string,
        ///           jobId: string,
        ///           taskId: string,
        ///           subtaskId: number,
        ///           taskState: TaskState,
        ///           executionInfo: {
        ///             startTime: string (ISO 8601 Format),
        ///             endTime: string (ISO 8601 Format),
        ///             exitCode: number,
        ///             containerInfo: {
        ///               containerId: string,
        ///               state: string,
        ///               error: string
        ///             },
        ///             failureInfo: {
        ///               category: ErrorCategory,
        ///               code: string,
        ///               message: string,
        ///               details: [
        ///                 {
        ///                   name: string,
        ///                   value: string
        ///                 }
        ///               ]
        ///             },
        ///             retryCount: number,
        ///             lastRetryTime: string (ISO 8601 Format),
        ///             requeueCount: number,
        ///             lastRequeueTime: string (ISO 8601 Format),
        ///             result: TaskExecutionResult
        ///           }
        ///         }
        ///       ],
        ///       startTask: {
        ///         commandLine: string,
        ///         containerSettings: {
        ///           containerRunOptions: string,
        ///           imageName: string,
        ///           registry: {
        ///             username: string,
        ///             password: string,
        ///             registryServer: string,
        ///             identityReference: {
        ///               resourceId: string
        ///             }
        ///           },
        ///           workingDirectory: ContainerWorkingDirectory
        ///         },
        ///         resourceFiles: [
        ///           {
        ///             autoStorageContainerName: string,
        ///             storageContainerUrl: string,
        ///             httpUrl: string,
        ///             blobPrefix: string,
        ///             filePath: string,
        ///             fileMode: string,
        ///             identityReference: ComputeNodeIdentityReference
        ///           }
        ///         ],
        ///         environmentSettings: [
        ///           {
        ///             name: string,
        ///             value: string
        ///           }
        ///         ],
        ///         userIdentity: {
        ///           username: string,
        ///           autoUser: {
        ///             scope: AutoUserScope,
        ///             elevationLevel: ElevationLevel
        ///           }
        ///         },
        ///         maxTaskRetryCount: number,
        ///         waitForSuccess: boolean
        ///       },
        ///       startTaskInfo: {
        ///         state: StartTaskState,
        ///         startTime: string (ISO 8601 Format),
        ///         endTime: string (ISO 8601 Format),
        ///         exitCode: number,
        ///         containerInfo: TaskContainerExecutionInformation,
        ///         failureInfo: TaskFailureInformation,
        ///         retryCount: number,
        ///         lastRetryTime: string (ISO 8601 Format),
        ///         result: TaskExecutionResult
        ///       },
        ///       certificateReferences: [
        ///         {
        ///           thumbprint: string,
        ///           thumbprintAlgorithm: string,
        ///           storeLocation: CertificateStoreLocation,
        ///           storeName: string,
        ///           visibility: [CertificateVisibility]
        ///         }
        ///       ],
        ///       errors: [
        ///         {
        ///           code: string,
        ///           message: string,
        ///           errorDetails: [NameValuePair]
        ///         }
        ///       ],
        ///       isDedicated: boolean,
        ///       endpointConfiguration: {
        ///         inboundEndpoints: [
        ///           {
        ///             name: string,
        ///             protocol: InboundEndpointProtocol,
        ///             publicIPAddress: string,
        ///             publicFQDN: string,
        ///             frontendPort: number,
        ///             backendPort: number
        ///           }
        ///         ]
        ///       },
        ///       nodeAgentInfo: {
        ///         version: string,
        ///         lastUpdateTime: string (ISO 8601 Format)
        ///       },
        ///       virtualMachineInfo: {
        ///         imageReference: {
        ///           publisher: string,
        ///           offer: string,
        ///           sku: string,
        ///           version: string,
        ///           virtualMachineImageId: string,
        ///           exactVersion: string
        ///         }
        ///       }
        ///     }
        ///   ],
        ///   odata.nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetComputeNodesAsync(string poolId, string filter = null, string select = null, int? maxResults = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, "ComputeNodeClient.GetComputeNodes");
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetComputeNodesRequest(poolId, filter, select, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context)
                        : CreateGetComputeNodesNextPageRequest(nextLink, poolId, filter, select, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "odata.nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Lists the Compute Nodes in the specified Pool. </summary>
        /// <param name="poolId"> The ID of the Pool from which you want to list Compute Nodes. </param>
        /// <param name="filter"> An OData $filter clause. For more information on constructing this filter, see https://docs.microsoft.com/en-us/rest/api/batchservice/odata-filters-in-batch#list-nodes-in-a-pool. </param>
        /// <param name="select"> An OData $select clause. </param>
        /// <param name="maxResults"> The maximum number of items to return in the response. A maximum of 1000 Compute Nodes can be returned. </param>
        /// <param name="timeout"> The maximum time that the server can spend processing the request, in seconds. The default is 30 seconds. </param>
        /// <param name="clientRequestId"> The caller-generated request identity, in the form of a GUID with no decoration such as curly braces, e.g. 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0. </param>
        /// <param name="returnClientRequestId"> Whether the server should return the client-request-id in the response. </param>
        /// <param name="ocpDate"> The time the request was issued. Client libraries typically set this to the current system clock time; set it explicitly if you are calling the REST API directly. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="poolId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="poolId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       id: string,
        ///       url: string,
        ///       state: ComputeNodeState,
        ///       schedulingState: SchedulingState,
        ///       stateTransitionTime: string (ISO 8601 Format),
        ///       lastBootTime: string (ISO 8601 Format),
        ///       allocationTime: string (ISO 8601 Format),
        ///       ipAddress: string,
        ///       affinityId: string,
        ///       vmSize: string,
        ///       totalTasksRun: number,
        ///       runningTasksCount: number,
        ///       runningTaskSlotsCount: number,
        ///       totalTasksSucceeded: number,
        ///       recentTasks: [
        ///         {
        ///           taskUrl: string,
        ///           jobId: string,
        ///           taskId: string,
        ///           subtaskId: number,
        ///           taskState: TaskState,
        ///           executionInfo: {
        ///             startTime: string (ISO 8601 Format),
        ///             endTime: string (ISO 8601 Format),
        ///             exitCode: number,
        ///             containerInfo: {
        ///               containerId: string,
        ///               state: string,
        ///               error: string
        ///             },
        ///             failureInfo: {
        ///               category: ErrorCategory,
        ///               code: string,
        ///               message: string,
        ///               details: [
        ///                 {
        ///                   name: string,
        ///                   value: string
        ///                 }
        ///               ]
        ///             },
        ///             retryCount: number,
        ///             lastRetryTime: string (ISO 8601 Format),
        ///             requeueCount: number,
        ///             lastRequeueTime: string (ISO 8601 Format),
        ///             result: TaskExecutionResult
        ///           }
        ///         }
        ///       ],
        ///       startTask: {
        ///         commandLine: string,
        ///         containerSettings: {
        ///           containerRunOptions: string,
        ///           imageName: string,
        ///           registry: {
        ///             username: string,
        ///             password: string,
        ///             registryServer: string,
        ///             identityReference: {
        ///               resourceId: string
        ///             }
        ///           },
        ///           workingDirectory: ContainerWorkingDirectory
        ///         },
        ///         resourceFiles: [
        ///           {
        ///             autoStorageContainerName: string,
        ///             storageContainerUrl: string,
        ///             httpUrl: string,
        ///             blobPrefix: string,
        ///             filePath: string,
        ///             fileMode: string,
        ///             identityReference: ComputeNodeIdentityReference
        ///           }
        ///         ],
        ///         environmentSettings: [
        ///           {
        ///             name: string,
        ///             value: string
        ///           }
        ///         ],
        ///         userIdentity: {
        ///           username: string,
        ///           autoUser: {
        ///             scope: AutoUserScope,
        ///             elevationLevel: ElevationLevel
        ///           }
        ///         },
        ///         maxTaskRetryCount: number,
        ///         waitForSuccess: boolean
        ///       },
        ///       startTaskInfo: {
        ///         state: StartTaskState,
        ///         startTime: string (ISO 8601 Format),
        ///         endTime: string (ISO 8601 Format),
        ///         exitCode: number,
        ///         containerInfo: TaskContainerExecutionInformation,
        ///         failureInfo: TaskFailureInformation,
        ///         retryCount: number,
        ///         lastRetryTime: string (ISO 8601 Format),
        ///         result: TaskExecutionResult
        ///       },
        ///       certificateReferences: [
        ///         {
        ///           thumbprint: string,
        ///           thumbprintAlgorithm: string,
        ///           storeLocation: CertificateStoreLocation,
        ///           storeName: string,
        ///           visibility: [CertificateVisibility]
        ///         }
        ///       ],
        ///       errors: [
        ///         {
        ///           code: string,
        ///           message: string,
        ///           errorDetails: [NameValuePair]
        ///         }
        ///       ],
        ///       isDedicated: boolean,
        ///       endpointConfiguration: {
        ///         inboundEndpoints: [
        ///           {
        ///             name: string,
        ///             protocol: InboundEndpointProtocol,
        ///             publicIPAddress: string,
        ///             publicFQDN: string,
        ///             frontendPort: number,
        ///             backendPort: number
        ///           }
        ///         ]
        ///       },
        ///       nodeAgentInfo: {
        ///         version: string,
        ///         lastUpdateTime: string (ISO 8601 Format)
        ///       },
        ///       virtualMachineInfo: {
        ///         imageReference: {
        ///           publisher: string,
        ///           offer: string,
        ///           sku: string,
        ///           version: string,
        ///           virtualMachineImageId: string,
        ///           exactVersion: string
        ///         }
        ///       }
        ///     }
        ///   ],
        ///   odata.nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   code: string,
        ///   message: {
        ///     lang: string,
        ///     value: string
        ///   },
        ///   values: [
        ///     {
        ///       key: string,
        ///       value: string
        ///     }
        ///   ]
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetComputeNodes(string poolId, string filter = null, string select = null, int? maxResults = null, int? timeout = null, Guid? clientRequestId = null, bool? returnClientRequestId = null, DateTimeOffset? ocpDate = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(poolId, nameof(poolId));

            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, "ComputeNodeClient.GetComputeNodes");
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetComputeNodesRequest(poolId, filter, select, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context)
                        : CreateGetComputeNodesNextPageRequest(nextLink, poolId, filter, select, maxResults, timeout, clientRequestId, returnClientRequestId, ocpDate, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "odata.nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        internal HttpMessage CreateAddUserRequest(string poolId, string nodeId, RequestContent content, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/users", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteUserRequest(string poolId, string nodeId, string userName, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/users/", false);
            uri.AppendPath(userName, true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateUserRequest(string poolId, string nodeId, string userName, RequestContent content, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/users/", false);
            uri.AppendPath(userName, true);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetComputeNodeRequest(string poolId, string nodeId, string select, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            if (select != null)
            {
                uri.AppendQuery("$select", select, true);
            }
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateRebootRequest(string poolId, string nodeId, RequestContent content, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/reboot", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateReimageRequest(string poolId, string nodeId, RequestContent content, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/reimage", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDisableSchedulingRequest(string poolId, string nodeId, RequestContent content, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/disablescheduling", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateEnableSchedulingRequest(string poolId, string nodeId, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/enablescheduling", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetRemoteLoginSettingsRequest(string poolId, string nodeId, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/remoteloginsettings", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetRemoteDesktopRequest(string poolId, string nodeId, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/rdp", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json, application/octet-stream");
            return message;
        }

        internal HttpMessage CreateUploadBatchServiceLogsRequest(string poolId, string nodeId, RequestContent content, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes/", false);
            uri.AppendPath(nodeId, true);
            uri.AppendPath("/uploadbatchservicelogs", false);
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json; odata=minimalmetadata");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetComputeNodesRequest(string poolId, string filter, string select, int? maxResults, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendPath("/pools/", false);
            uri.AppendPath(poolId, true);
            uri.AppendPath("/nodes", false);
            if (filter != null)
            {
                uri.AppendQuery("$filter", filter, true);
            }
            if (select != null)
            {
                uri.AppendQuery("$select", select, true);
            }
            if (maxResults != null)
            {
                uri.AppendQuery("maxresults", maxResults.Value, true);
            }
            if (timeout != null)
            {
                uri.AppendQuery("timeout", timeout.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetComputeNodesNextPageRequest(string nextLink, string poolId, string filter, string select, int? maxResults, int? timeout, Guid? clientRequestId, bool? returnClientRequestId, DateTimeOffset? ocpDate, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw(_batchUrl, false);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            if (clientRequestId != null)
            {
                request.Headers.Add("client-request-id", clientRequestId.Value);
            }
            if (returnClientRequestId != null)
            {
                request.Headers.Add("return-client-request-id", returnClientRequestId.Value);
            }
            if (ocpDate != null)
            {
                request.Headers.Add("ocp-date", ocpDate.Value, "R");
            }
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier201;
        private static ResponseClassifier ResponseClassifier201 => _responseClassifier201 ??= new StatusCodeClassifier(stackalloc ushort[] { 201 });
        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier202;
        private static ResponseClassifier ResponseClassifier202 => _responseClassifier202 ??= new StatusCodeClassifier(stackalloc ushort[] { 202 });
    }
}
